#include "includes.hpp"
#include <BRepMesh_IncrementalMesh.hxx>
#include <BRep_Tool.hxx>
#include <TopExp_Explorer.hxx>
#include <TopoDS_Face.hxx>
#include <Poly_Triangulation.hxx>
#include <Poly_Triangle.hxx>
#include <gp_Pnt.hxx>
#include <gp_Vec.hxx>
#include <Geom_CylindricalSurface.hxx>
#include <GeomLProp_SLProps.hxx>

#include <fstream>
#include <vector>
#include <array>

void WriteBinarySTL(const TopoDS_Shape& shape, const std::string& filename) {
    // Mesh the shape
    BRepMesh_IncrementalMesh mesh(shape, 0.1);

    std::ofstream file(filename, std::ios::binary);
    char header[80] = "Binary STL generated by OpenCascade";
    file.write(header, 80);

    std::vector<std::array<gp_Pnt, 3>> triangles;

    for (TopExp_Explorer faceExp(shape, TopAbs_FACE); faceExp.More(); faceExp.Next()) {
        TopoDS_Face face = TopoDS::Face(faceExp.Current());
        TopLoc_Location loc = face.Location();
        gp_Trsf trsf = loc.Transformation();

        Handle(Poly_Triangulation) triangulation = BRep_Tool::Triangulation(face, loc);
        if (triangulation.IsNull()) continue;

        // Get triangle array and loop over its bounds
        const Poly_Array1OfTriangle& triArray = triangulation->Triangles();
        for (Standard_Integer i = triArray.Lower(); i <= triArray.Upper(); ++i) {
            Standard_Integer n1, n2, n3;
            triArray(i).Get(n1, n2, n3);

            gp_Pnt p1 = triangulation->Node(n1).Transformed(trsf);
            gp_Pnt p2 = triangulation->Node(n2).Transformed(trsf);
            gp_Pnt p3 = triangulation->Node(n3).Transformed(trsf);

            triangles.push_back({p1, p2, p3});
        }
    }

    uint32_t triCount = static_cast<uint32_t>(triangles.size());
    file.write(reinterpret_cast<char*>(&triCount), 4);

    for (const auto& tri : triangles) {
        gp_Vec v1(tri[0], tri[1]);
        gp_Vec v2(tri[0], tri[2]);
        gp_Vec normalVec = v1.Crossed(v2);
        if (normalVec.SquareMagnitude() > gp::Resolution())
            normalVec.Normalize();
        else
            normalVec = gp_Vec(0.0, 0.0, 0.0);

        float normal[3] = {
            static_cast<float>(normalVec.X()),
            static_cast<float>(normalVec.Y()),
            static_cast<float>(normalVec.Z())
        };
        file.write(reinterpret_cast<char*>(normal), 12);

        for (const gp_Pnt& p : tri) {
            float coords[3] = {
                static_cast<float>(p.X()),
                static_cast<float>(p.Y()),
                static_cast<float>(p.Z())
            };
            file.write(reinterpret_cast<char*>(coords), 12);
        }

        uint16_t attrByteCount = 0;
        file.write(reinterpret_cast<char*>(&attrByteCount), 2);
    }

    file.close();
}

#include <iomanip>
#include <sstream>
#include <string>
#include <cmath>
#include <algorithm>


#include <sstream>
#include <iomanip>

#include <V3d_View.hxx>
#include <gp_Vec.hxx>
#include <gp_Dir.hxx>
#include <gp.hxx>
#include <cmath>

static inline gp_Dir sgnDir(const gp_Dir& axis, Standard_Real dot) {
    return (dot >= 0.0) ? axis : gp_Dir(-axis.X(), -axis.Y(), -axis.Z());
}

void GetAlignedCameraVectors(const Handle(V3d_View)& view,
                             gp_Vec& end_proj_global,
                             gp_Vec& end_up_global)
{
    // 1) Read camera forward (Proj) and Up
    Standard_Real vx, vy, vz, ux, uy, uz;
    view->Proj(vx, vy, vz);
    view->Up(ux, uy, uz);

    gp_Dir viewDir(vx, vy, vz);
    gp_Dir upDir(ux, uy, uz);

    const gp_Dir X(1,0,0), Y(0,1,0), Z(0,0,1);

    // 2) Choose nearest axis-aligned plane normal (±X, ±Y, ±Z) by max |dot|,
    //    but KEEP the sign for facing direction.
    Standard_Real dx = viewDir.Dot(X);
    Standard_Real dy = viewDir.Dot(Y);
    Standard_Real dz = viewDir.Dot(Z);

    Standard_Real ax = std::abs(dx), ay = std::abs(dy), az = std::abs(dz);

    gp_Dir normal;
    enum class Plane { YZ, ZX, XY } plane; // plane orthogonal to chosen normal

    if (ax >= ay && ax >= az) {
        normal = sgnDir(X, dx);
        plane = Plane::YZ; // normal along X -> plane is YZ
    } else if (ay >= ax && ay >= az) {
        normal = sgnDir(Y, dy);
        plane = Plane::ZX; // normal along Y -> plane is ZX
    } else {
        normal = sgnDir(Z, dz);
        plane = Plane::XY; // normal along Z -> plane is XY
    }

    // 3) Project current up onto the snapped plane (minimize roll change)
    gp_Vec upVec(upDir.X(), upDir.Y(), upDir.Z());
    gp_Vec nVec(normal.X(), normal.Y(), normal.Z());
    gp_Vec upOnPlane = upVec - (upVec.Dot(nVec)) * nVec;

    // 4) If degenerate, fall back to the axis in the plane with strongest alignment to original up
    bool degenerate = (upOnPlane.SquareMagnitude() < 1e-14);
    gp_Dir bestUp;

    auto chooseUpInPlane = [&](const gp_Dir& a, const gp_Dir& b, const gp_Vec& ref) -> gp_Dir {
        // pick among ±a, ±b the one closest to ref (use sign of dot to set direction)
        Standard_Real da = ref.Dot(gp_Vec(a.X(), a.Y(), a.Z()));
        Standard_Real db = ref.Dot(gp_Vec(b.X(), b.Y(), b.Z()));
        if (std::abs(da) >= std::abs(db)) {
            return (da >= 0.0) ? a : gp_Dir(-a.X(), -a.Y(), -a.Z());
        } else {
            return (db >= 0.0) ? b : gp_Dir(-b.X(), -b.Y(), -b.Z());
        }
    };

    if (plane == Plane::YZ) {
        bestUp = chooseUpInPlane(Y, Z, degenerate ? upVec : upOnPlane);
    } else if (plane == Plane::ZX) {
        bestUp = chooseUpInPlane(Z, X, degenerate ? upVec : upOnPlane);
    } else { // Plane::XY
        bestUp = chooseUpInPlane(X, Y, degenerate ? upVec : upOnPlane);
    }

    // 5) Build a right-handed orthonormal basis and re-derive up to ensure exact orthogonality
    gp_Vec right = nVec.Crossed(gp_Vec(bestUp.X(), bestUp.Y(), bestUp.Z()));
    if (right.SquareMagnitude() < 1e-14) {
        // Extremely rare: if bestUp accidentally parallel (numerical), pick the other axis in plane
        if (plane == Plane::YZ) {
            bestUp = (std::abs(bestUp.Dot(Y)) > 0.5) ? Z : Y;
        } else if (plane == Plane::ZX) {
            bestUp = (std::abs(bestUp.Dot(Z)) > 0.5) ? X : Z;
        } else {
            bestUp = (std::abs(bestUp.Dot(X)) > 0.5) ? Y : X;
        }
        right = nVec.Crossed(gp_Vec(bestUp.X(), bestUp.Y(), bestUp.Z()));
    }

    gp_Dir rightDir(right);
    gp_Dir correctedUp((rightDir ^ normal)); // right x normal -> up (right-handed)

    // 6) Output snapped vectors as gp_Vec
    end_proj_global = gp_Vec(normal.X(),     normal.Y(),     normal.Z());
    end_up_global   = gp_Vec(correctedUp.X(), correctedUp.Y(), correctedUp.Z());
}


#include <TopoDS_Compound.hxx>
#include <TopoDS_Shape.hxx>
#include <TopoDS_Iterator.hxx>
#include <BRep_Builder.hxx>
#include <functional>

// Generic function: replaces one shape inside a compound with a modified version
void ReplaceShapeInCompound(
    TopoDS_Compound& compound,
    TopoDS_Shape& targetShape,
    const std::function<TopoDS_Shape(const TopoDS_Shape&)>& modifier
) {
    BRep_Builder builder;
    TopoDS_Compound newCompound;
    builder.MakeCompound(newCompound);

    for (TopoDS_Iterator it(compound); it.More(); it.Next()) {
        const TopoDS_Shape& currentShape = it.Value();

        if (currentShape.IsSame(targetShape)) {
            TopoDS_Shape newShape = modifier(currentShape);
            if (!newShape.IsNull()) {
                builder.Add(newCompound, newShape);
                targetShape = newShape; // update reference
            } else {
                builder.Add(newCompound, currentShape); // fallback
            }
        } else {
            builder.Add(newCompound, currentShape);
        }
    }

    compound = newCompound;
}





#include <BRepPrimAPI_MakeBox.hxx>
#include <BRepFilletAPI_MakeFillet.hxx>
#include <TopExp_Explorer.hxx>
#include <TopoDS.hxx>
#include <TopoDS_Edge.hxx>
#include <Standard_Real.hxx>
#include <iostream>

TopoDS_Shape ApplyFilletToAllEdges(const TopoDS_Shape shape, Standard_Real radius) {
    BRepFilletAPI_MakeFillet fillet(shape);

    // Adicionar todas as arestas
    for (TopExp_Explorer exp(shape, TopAbs_EDGE); exp.More(); exp.Next()) {
        const TopoDS_Edge& edge = TopoDS::Edge(exp.Current());
        fillet.Add(radius, edge);
    }

    // Construir o fillet
    fillet.Build();

    if (!fillet.IsDone()) {
        std::cerr << "Fillet falhou!" << std::endl;
        return shape; // devolve shape original
    }

    return fillet.Shape();
}

 




std::string SerializeFaceInvariant(const TopoDS_Face& face) {
    Standard_Real umin, umax, vmin, vmax;
    BRepTools::UVBounds(face, umin, umax, vmin, vmax);

    // just identify surface type
    Handle(Geom_Surface) surf = BRep_Tool::Surface(face);
    std::ostringstream oss;

    if (surf->DynamicType() == STANDARD_TYPE(Geom_Plane)) {
        oss << "PLN;";
    } else if (surf->DynamicType() == STANDARD_TYPE(Geom_CylindricalSurface)) {
        Handle(Geom_CylindricalSurface) cyl =
            Handle(Geom_CylindricalSurface)::DownCast(surf);
        oss << "CYL;R=" << cyl->Radius() << ";";
    }
    // … add other analytic cases if needed

    // store UV bounds
    oss << "U:[" << umin << "," << umax << "];"
        << "V:[" << vmin << "," << vmax << "];";

    // orientation
    oss << "ORI=" << (int)face.Orientation();

    return oss.str();
}



std::string SerializeCompact(const std::string& partName,
                              int index,
                              const gp_Dir& normal,
                              const gp_Pnt& centroid,
                              double area)
{
    auto fmt = [](double v,int precision=2) {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(2) << v;
        std::string s = oss.str();
        // strip trailing zeros and optional decimal point
        if (s.find('.') != std::string::npos) {
            while (!s.empty() && s.back() == '0') s.pop_back();
            if (!s.empty() && s.back() == '.') s.pop_back();
        }
        return s;
    };

    std::ostringstream out;
    out << partName << " " << index << " "
        << fmt(normal.X()) << "," << fmt(normal.Y()) << "," << fmt(normal.Z()) << " "
        << fmt(centroid.X()) << "," << fmt(centroid.Y()) << "," << fmt(centroid.Z()) << " "
        << fmt(area);
    return out.str();
}






// Format with up to 2 decimals; drop trailing ".0"/".00" for integers (e.g., 100.00 -> 100)
inline std::string fmt2(double v) {
    // Round to 2 decimals to avoid cases like 0.999999999
    double r = std::round(v * 100.0) / 100.0;

    // Avoid "-0" after rounding
    if (std::fabs(r) < 1e-12) r = 0.0;

    std::ostringstream ss;
    ss.setf(std::ios::fixed);
    ss << std::setprecision(2) << r;

    std::string s = ss.str();
    // Trim trailing zeros, then trailing dot if any
    if (auto pos = s.find('.'); pos != std::string::npos) {
        while (!s.empty() && s.back() == '0') s.pop_back();
        if (!s.empty() && s.back() == '.') s.pop_back();
    }
    if (s == "-0") s = "0";
    return s;
}

std::string FaceToString(const TopoDS_Face& face) {
    Handle(Geom_Surface) surface = BRep_Tool::Surface(face);
    Handle(Geom_Plane) plane = Handle(Geom_Plane)::DownCast(surface);
    if (plane.IsNull()) return "";

    gp_Ax3 ax3 = plane->Position();
    gp_Pnt origin = ax3.Location();
    gp_Dir normal = ax3.Direction();
    gp_Dir xDir   = ax3.XDirection();

    std::ostringstream oss;
    // origin
    oss << fmt2(origin.X()) << "," << fmt2(origin.Y()) << "," << fmt2(origin.Z()) << " ";
    // normal
    oss << fmt2(normal.X()) << "," << fmt2(normal.Y()) << "," << fmt2(normal.Z()) << " ";
    // X direction
    oss << fmt2(xDir.X()) << "," << fmt2(xDir.Y()) << "," << fmt2(xDir.Z());

    return oss.str();
}

gp_Ax3 get_face_local_cs(const TopoDS_Face& face) {
    Handle(Geom_Surface) surf = BRep_Tool::Surface(face);

    // Planar face → easy
    if (surf->DynamicType() == STANDARD_TYPE(Geom_Plane)) {
        Handle(Geom_Plane) plane = Handle(Geom_Plane)::DownCast(surf);
        return plane->Position();
    }

    // Generic: use point + normal at center of bounds
    Standard_Real umin, umax, vmin, vmax;
    BRepTools::UVBounds(face, umin, umax, vmin, vmax);
    gp_Pnt2d uv((umin+umax)*0.5, (vmin+vmax)*0.5);

    GeomLProp_SLProps props(surf, uv.X(), uv.Y(), 1, 1e-6);
    gp_Pnt p = props.Value();
    gp_Dir n = props.Normal();

    // Choose arbitrary X axis (project global X onto tangent plane)
    gp_Dir vx(1,0,0);
    if (vx.IsParallel(n, Precision::Angular())) vx = gp_Dir(0,1,0);
    gp_Dir xdir = vx ^ n;
    gp_Dir ydir = n ^ xdir;

    return gp_Ax3(p, n, xdir);
}

#include <sstream>
#include <string>
#include <algorithm> // for std::replace

gp_Trsf StringToTransformation(const std::string& str) {
    // Make a copy and replace commas with spaces
    std::string cleaned = str;
    std::replace(cleaned.begin(), cleaned.end(), ',', ' ');

    // Parse the nine numeric values
    std::istringstream iss(cleaned);
    double ox, oy, oz, nx, ny, nz, xx, xy, xz;
    iss >> ox >> oy >> oz >> nx >> ny >> nz >> xx >> xy >> xz;

    // Build geometry
    gp_Pnt origin(ox, oy, oz);
    gp_Dir normal(nx, ny, nz);
    gp_Dir xDir(xx, xy, xz);

    gp_Ax3 ax3(origin, normal, xDir);

    gp_Trsf trsf;
    trsf.SetTransformation(ax3);
    return trsf;
}






#if 0
#include <string>
#include <string_view>

static inline bool is_space(char c) {
    return c == ' ' || c == '\t' || c == '\r';
}
static inline bool is_ident_start(char c) {
    return (c == '_') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}
static inline bool is_ident_char(char c) {
    return is_ident_start(c) || (c >= '0' && c <= '9');
}

std::string translate_shorthand_v1(std::string_view src) {
    std::string out;
    out.reserve(src.size() + src.size() / 16 + 32); // small headroom

    size_t i = 0, n = src.size();
    while (i < n) {
        // Get line [lineStart, lineEnd)
        size_t lineStart = i;
        size_t lineEnd = src.find('\n', i);
        if (lineEnd == std::string_view::npos) lineEnd = n;
        std::string_view line = src.substr(lineStart, lineEnd - lineStart);

        // Parse leading spaces, name, spaces
        size_t p = 0;
        while (p < line.size() && is_space(line[p])) ++p;

        // Fast path: empty or comment line
        if (p >= line.size() || (line[p] == '-' && p + 1 < line.size() && line[p + 1] == '-')) {
            out.append(line.data(), line.size());
            if (lineEnd < n) out.push_back('\n');
            i = (lineEnd == n) ? n : lineEnd + 1;
            continue;
        }

        size_t nameStart = p;
        while (p < line.size() && is_ident_char(line[p])) ++p;
        std::string_view name = line.substr(nameStart, p - nameStart);

        size_t q = p;
        while (q < line.size() && is_space(line[q])) ++q;

        bool handled = false;

        // Part name -> Part("name")
        if (name == "Part" && q < line.size() && is_ident_start(line[q])) {
            size_t idStart = q;
            size_t idEnd = idStart;
            while (idEnd < line.size() && is_ident_char(line[idEnd])) ++idEnd;

            out.append("Part(\"", 6);
            out.append(line.data() + idStart, idEnd - idStart);
            out.push_back('"');
            out.push_back(')');

            // Preserve any trailing content (e.g., inline comment)
            if (idEnd < line.size()) {
                out.push_back(' ');
                out.append(line.data() + idEnd, line.size() - idEnd);
            }
            handled = true;
        }
        // pl args -> pl("args"), unless already pl(...)
        else if (name == "pl" && q < line.size()) {
            if (line[q] == '(') {
                out.append(line.data(), line.size()); // already a call
            } else {
                out.append("pl(\"", 4);
                // Escape " and \ in args
                for (size_t t = q; t < line.size(); ++t) {
                    char c = line[t];
                    if (c == '\\' || c == '\"') out.push_back('\\');
                    out.push_back(c);
                }
                out.append("\")", 2);
            }
            handled = true;
        }
        // offset/extrude args -> name(args), unless already name(...)
        else if ((name == "offset" || name == "extrude" || name == "clone"  ) && q < line.size()) {
            if (line[q] == '(') {
                out.append(line.data(), line.size()); // already a call
            } else {
                // Trim trailing spaces from args
                size_t argEnd = line.size();
                while (argEnd > q && is_space(line[argEnd - 1])) --argEnd;

                out.append(line.data() + nameStart, name.size());
                out.push_back('(');
                out.append(line.data() + q, argEnd - q);
                out.push_back(')');
            }
            handled = true;
        }

        if (!handled) {
            // Leave line unchanged
            out.append(line.data(), line.size());
        }

        if (lineEnd < n) out.push_back('\n');
        i = (lineEnd == n) ? n : lineEnd + 1;
    }
    return out;
}
#endif

#include <string>
#include <string_view>
#include <unordered_set>
#include <vector>

// char tests
static inline bool is_space(char c) {
  return c==' '||c=='\t'||c=='\r';
}
static inline bool is_ident_start(char c) {
  return (c=='_') || (c>='A'&&c<='Z') || (c>='a'&&c<='z');
}
static inline bool is_ident_char(char c) {
  return is_ident_start(c) || (c>='0'&&c<='9');
}
static inline char to_lower(char c) {
  return (c>='A'&&c<='Z') ? char(c - 'A' + 'a') : c;
}
static std::string lower_sv(std::string_view sv) {
  std::string s; s.reserve(sv.size());
  for (char c : sv) s.push_back(to_lower(c));
  return s;
}
static inline char sh_tolower(char c) { return (c>='A'&&c<='Z') ? char(c - 'A' + 'a') : c; }
static std::string sh_lower(std::string_view sv) {
    std::string s; s.resize(sv.size());
    for (size_t i=0;i<sv.size();++i) s[i]=sh_tolower(sv[i]);
    return s;
}

std::string translate_shorthand(std::string_view src,
								const std::unordered_set<std::string>& S,  // single-string commands
								const std::unordered_set<std::string>& A   // arg-first commands
) {
	std::string out;
	out.reserve(src.size() + src.size() / 16 + 32);

	size_t i = 0, n = src.size();
	while (i < n) {
		size_t lineEnd = src.find('\n', i);
		if (lineEnd == std::string_view::npos) lineEnd = n;
		std::string_view line = src.substr(i, lineEnd - i);

		// skip blank/comment
		size_t p = 0;
		while (p < line.size() && is_space(line[p])) ++p;
		if (p >= line.size() || (line[p] == '-' && p + 1 < line.size() && line[p + 1] == '-')) {
			out.append(line.data(), line.size());
			if (lineEnd < n) out.push_back('\n');
			i = (lineEnd == n ? n : lineEnd + 1);
			continue;
		}

		// extract command name
		size_t nameStart = p;
		while (p < line.size() && is_ident_char(line[p])) ++p;
		std::string_view name = line.substr(nameStart, p - nameStart);
		std::string lname = lower_sv(name);

		// skip spaces to argument start
		size_t q = p;
		while (q < line.size() && is_space(line[q])) ++q;

		bool handled = false;

		// if already parentheses, pass through
		if (q < line.size() && line[q] == '(') {
			out.append(line.data(), line.size());
			handled = true;
		}
		// single-string commands → wrap entire tail in quotes
		else if (!handled && S.count(lname) && q < line.size()) {
			out.append(line.data() + nameStart, name.size());
			out.push_back('(');
			out.push_back('"');
			for (size_t t = q; t < line.size(); ++t) {
				char c = line[t];
				if (c == '"' || c == '\\') out.push_back('\\');
				out.push_back(c);
			}
			out.push_back('"');
			out.push_back(')');
			handled = true;
		}
		// arg-first commands → split tail on spaces and join by commas
		else if (!handled && A.count(lname) && q < line.size()) {
			out.append(line.data() + nameStart, name.size());
			out.push_back('(');
			// collect tokens
			std::vector<std::string_view> toks;
			size_t r = q;
			while (r < line.size()) {
				while (r < line.size() && is_space(line[r])) ++r;
				if (r >= line.size()) break;
				size_t e = r;
				while (e < line.size() && !is_space(line[e])) ++e;
				toks.emplace_back(line.data() + r, e - r);
				r = e;
			}
			for (size_t ti = 0; ti < toks.size(); ++ti) {
				if (ti) out.push_back(',');
				out.append(toks[ti].data(), toks[ti].size());
			}
			out.push_back(')');
			handled = true;
		}

		if (!handled) {
			out.append(line.data(), line.size());
		}
		if (lineEnd < n) out.push_back('\n');
		i = (lineEnd == n ? n : lineEnd + 1);
	}

	return out;
}

std::string translate_shorthand(std::string_view src){
	std::vector<std::string> vSstring = {"Part","Pl","Move","Rotate"};
	std::vector<std::string> vAstring = {"Offset","Extrude","Fuse","Clone","Intersect","Revolution"};

	std::unordered_set<std::string> S, A;
	S.reserve(vSstring.size()); A.reserve(vAstring.size());
	for (auto& s : vSstring) S.insert(sh_lower(s));
	for (auto& s : vAstring) A.insert(sh_lower(s));

	std::string code = translate_shorthand(src, S, A);

	//cotm(code);


	return code;
	// return translate_shorthand(src, S, A);

}

static int shorthand_searcher(lua_State* L) {
    const char* modname = luaL_checkstring(L, 1);

    // filepath = package.searchpath(modname, package.path)
    lua_getglobal(L, "package");
    lua_getfield(L, -1, "searchpath");
    lua_pushvalue(L, 1);                 // modname
    lua_getglobal(L, "package");
    lua_getfield(L, -1, "path");         // package.path
    lua_call(L, 2, 1);                    // -> filepath | nil+errmsg
    const char* filepath = lua_tostring(L, -1);

    if (!filepath) {
        // Return the aggregated "not found" message string for require()
        return 1; // leave the error message on the stack
    }

    // Read file
    std::ifstream f(filepath, std::ios::binary);
    if (!f) {
        lua_pushfstring(L, "\n\tno file '%s'", filepath);
        return 1;
    }
    std::string src((std::istreambuf_iterator<char>(f)), {});





    std::string code = translate_shorthand(src);

    // Load translated chunk
    if (luaL_loadbuffer(L, code.data(), code.size(), filepath) != LUA_OK) {
        return lua_error(L);
    }
    return 1; // return the loaded function
}

void install_shorthand_searcher(lua_State* L) {
    lua_getglobal(L, "package");
    lua_getfield(L, -1, "searchers"); // Lua 5.2+ ("loaders" on 5.1)
    lua_pushcfunction(L, shorthand_searcher);
    lua_rawseti(L, -2, 2);            // replace the Lua file searcher
    lua_pop(L, 2);                    // pop searchers, package
}






#if 0
#include <vector>
#include <functional>
#include <string>

static std::vector<std::function<void(std::string_view)>> g_str_cmds;
static std::vector<std::function<void(double)>>           g_num_cmds;

static int l_call_str(lua_State* L) {
    size_t idx = (size_t)lua_tointeger(L, lua_upvalueindex(1));
    size_t len = 0;
    const char* s = luaL_checklstring(L, 1, &len);
    g_str_cmds[idx](std::string_view(s, len));
    return 0;
}

static int l_call_num(lua_State* L) {
    size_t idx = (size_t)lua_tointeger(L, lua_upvalueindex(1));
    double v = luaL_checknumber(L, 1);
    g_num_cmds[idx](v);
    return 0;
}

void register_string_cmds(lua_State* L,
                          const std::vector<std::pair<std::string, std::function<void(std::string_view)>>> &cmds) {
    for (const auto& [name, fn] : cmds) {
        size_t idx = g_str_cmds.size();
        g_str_cmds.push_back(fn);
        lua_pushinteger(L, (lua_Integer)idx);   // upvalue: index
        lua_pushcclosure(L, l_call_str, 1);
        lua_setglobal(L, name.c_str());
    }
}

void register_number_cmds(lua_State* L, const std::vector<std::pair<std::string, std::function<void(double)>>> &cmds) {
    for (const auto& [name, fn] : cmds) {
        size_t idx = g_num_cmds.size();
        g_num_cmds.push_back(fn);
        lua_pushinteger(L, (lua_Integer)idx);   // upvalue: index
        lua_pushcclosure(L, l_call_num, 1);
        lua_setglobal(L, name.c_str());
    }
}
#endif
