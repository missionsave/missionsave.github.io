<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auto-Tuning Pro Analyst</title>
<style>
:root {
    --bg: #0f172a;
    --panel: #1e293b;
    --border: #334155;
    --text: #e2e8f0;
    --muted: #94a3b8;
    --accent: #3b82f6;
    --red: #ef4444;
    --black: #1e293b;
    --green: #22c55e;
    --hot: #f59e0b;
    --glow: rgba(59, 130, 246, 0.5);
}

body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    margin: 0;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
}

.container {
    width: 100%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.hud {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.prediction-box { display: flex; flex-direction: column; gap: 10px; }
.hud-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--muted); font-weight: 600; }
.balls-container { display: flex; gap: 12px; }

.ball {
    width: 44px; height: 44px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-weight: 700; font-size: 18px;
    box-shadow: inset 0 -4px 4px rgba(0,0,0,0.3);
    border: 2px solid rgba(255,255,255,0.1);
    transition: transform 0.2s;
}

.ball.zero { background: var(--green); color: white; }
.ball.red { background: var(--red); color: white; }
.ball.black { background: #334155; color: white; }

.confidence-meter { text-align: right; }
.meter-val { font-size: 24px; font-weight: bold; color: var(--accent); }
.stat-row { display: flex; gap: 20px; margin-top: 5px; font-size: 13px; color: var(--muted); }

.history-strip {
    background: rgba(30, 41, 59, 0.5);
    border-radius: 8px;
    padding: 10px;
    display: flex; gap: 6px;
    overflow-x: auto; min-height: 40px;
    scrollbar-width: thin;
}

.mini-ball { width: 28px; height: 28px; font-size: 12px; flex-shrink: 0; }

.controls { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
button {
    background: var(--panel); border: 1px solid var(--border);
    color: var(--text); padding: 12px; border-radius: 8px;
    cursor: pointer; font-weight: 600; transition: all 0.2s;
}
button:hover { background: #334155; border-color: var(--accent); }

.input-grid {
    display: grid; grid-template-columns: repeat(12, 1fr); gap: 6px;
    background: #000; padding: 15px; border-radius: 12px;
}

.grid-btn { aspect-ratio: 1; border-radius: 4px; border: none; font-size: 14px; font-weight: bold; color: white; }
.zero-btn { grid-column: span 12; aspect-ratio: auto; height: 40px; background: var(--green); margin-bottom: 6px; }

.analysis-panel {
    background: var(--panel); padding: 15px; border-radius: 8px;
    font-size: 12px; color: var(--muted); line-height: 1.6;
}

.tune-badge {
    background: var(--accent); color: white;
    padding: 2px 6px; border-radius: 4px; font-size: 10px;
    margin-left: 8px; vertical-align: middle;
}

#prediction-set .ball { box-shadow: 0 0 10px var(--glow); border: 2px solid var(--accent); }

@media (max-width: 600px) {
    .input-grid { grid-template-columns: repeat(6, 1fr); }
    .zero-btn { grid-column: span 6; }
    .controls { grid-template-columns: repeat(2, 1fr); }
}
</style>
</head>
<body>

<div class="container">
    <div class="hud">
        <div class="prediction-box">
            <div class="hud-label">Optimized Sector Prediction</div>
            <div id="prediction-set" class="balls-container">
                <div class="ball black" style="opacity:0.3">?</div>
                <div class="ball red" style="opacity:0.3">?</div>
                <div class="ball black" style="opacity:0.3">?</div>
                <div class="ball red" style="opacity:0.3">?</div>
            </div>
        </div>

        <div class="confidence-meter">
            <div class="hud-label">Current Strategy Wins</div>
            <div class="meter-val" id="total-wins">0</div>
            <div class="stat-row">
                <span>Rate: <strong id="win-rate" style="color:#fff">0%</strong></span>
                <span>Conf: <strong id="confidence-val" style="color:var(--accent)">0%</strong></span>
            </div>
        </div>
    </div>

    <div class="analysis-panel">
        <div style="display: flex; justify-content: space-between;">
            <strong>Auto-Tune Status: <span id="algorithm-status" style="color:var(--accent)">Idle</span></strong>
            <span id="best-params" style="font-family: monospace; color: var(--hot);"></span>
        </div>
        <div style="margin-top:8px">
            Best Predicted Positions: <strong id="score-positions" style="color:white">–</strong>
        </div>
    </div>

    <div class="history-strip" id="history-strip"></div>

    <div class="controls">
        <button onclick="undo()" style="color:#f59e0b">Undo</button>
        <button onclick="resetData()" style="color:#ef4444">Reset</button>
        <button onclick="addRandom()">Random</button>
        <button onclick="sim10()">Sim 10</button>
    </div>

    <button class="grid-btn zero-btn" onclick="addSpin(0)">0</button>
    <div class="input-grid" id="number-grid"></div>
</div>

<script>
/**
 * CONSTANTS & DATA
 */
const WHEEL = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
const REDS = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];

// The "Tuning Grid" - The engine will test combinations of these
const TUNE_OPTIONS = {
    WINDOW_SIZES: [6, 8, 10, 12],
    NEIGHBOR_WEIGHTS: [0.35, 0.45, 0.55],
    WIN_BOOSTS: [1.3, 1.6, 1.9]
};

let history = [];
let currentBestConfig = {
    WINDOW_SIZE: 10,
    NEIGHBOR_WEIGHT: 0.45,
    RECENCY_DECAY: 0.88,
    WIN_POSITION_BOOST: 1.6,
    COLD_PENALTY: 0.6,
    STABILITY_BONUS: 0.4
};

// State updated after reprocessing
let currentWins = 0;
let lastPrediction = [];
let winnerScorePositions = [];

/**
 * CORE LOGIC ENGINE
 */
function getNeighbors(num, dist = 2) {
    const i = WHEEL.indexOf(num);
    if (i < 0) return [];
    const len = WHEEL.length;
    let out = [];
    for (let d = 1; d <= dist; d++) {
        out.push(WHEEL[(i + d) % len], WHEEL[(i - d + len) % len]);
    }
    return out;
}

// Pure function for calculating scores given a specific config
function calculateScores(histChunk, config, prevPred = []) {
    let heat = new Map();
    for (let i = 0; i <= 36; i++) heat.set(i, 0);
    if (histChunk.length < 3) return heat;

    const window = histChunk.slice(-config.WINDOW_SIZE);
    window.forEach((num, idx) => {
        let weight = Math.pow(1.15, idx + 1);
        heat.set(num, heat.get(num) + weight);
        getNeighbors(num, 2).forEach(n => heat.set(n, heat.get(n) + weight * config.NEIGHBOR_WEIGHT));
    });

    histChunk.slice(-3).forEach(n => heat.set(n, heat.get(n) * config.COLD_PENALTY));
    prevPred.forEach(n => heat.set(n, heat.get(n) + config.STABILITY_BONUS));
    return heat;
}

function getSorted(heatMap) {
    return [...heatMap.entries()].sort((a, b) => b[1] - a[1]);
}

/**
 * AUTO-TUNE & BACKTEST ENGINE
 */
function backtest(config) {
    let wins = 0;
    let scorePos = [];
    let tempHist = [];
    let activePred = [];

    for (let i = 0; i < history.length; i++) {
        const val = history[i];
        if (tempHist.length >= 3) {
            const scores = calculateScores(tempHist, config, activePred);
            const sorted = getSorted(scores);
            if (activePred.includes(val)) wins++;
            const rank = sorted.findIndex(e => e[0] === val);
            if (rank !== -1) scorePos.push(rank + 1);
        }
        tempHist.push(val);
        const nextScores = calculateScores(tempHist, config, activePred);
        activePred = getPredFromPos(tempHist, scorePos, nextScores);
    }
    return { wins, scorePos, activePred };
}

function getPredFromPos(hist, positions, scoresMap) {
    const sorted = getSorted(scoresMap);
    let targetPos = [];
    for (let i = positions.length - 1; i >= 0 && targetPos.length < 3; i--) {///
        let p = positions[i];
        if (p <= 18 && !targetPos.includes(p)) targetPos.push(p);
    }
    if (targetPos.length === 0) targetPos = [1, 2, 3, 4];
    return targetPos.map(p => sorted[p - 1]?.[0]).filter(n => n !== undefined);
}

function autoTune() {
    if (history.length < 5) return;
    
    document.getElementById('algorithm-status').innerText = "Tuning...";
    let bestWins = -1;
    let bestCfg = { ...currentBestConfig };

    // Iterate through a subset of possibilities (Grid Search)
    for (let w of TUNE_OPTIONS.WINDOW_SIZES) {
        for (let nw of TUNE_OPTIONS.NEIGHBOR_WEIGHTS) {
            for (let b of TUNE_OPTIONS.WIN_BOOSTS) {
                let testCfg = { ...currentBestConfig, WINDOW_SIZE: w, NEIGHBOR_WEIGHT: nw, WIN_POSITION_BOOST: b };
                let result = backtest(testCfg);
                if (result.wins > bestWins) {
                    bestWins = result.wins;
                    bestCfg = testCfg;
                }
            }
        }
    }

    currentBestConfig = bestCfg;
    const final = backtest(currentBestConfig);
    currentWins = final.wins;
    winnerScorePositions = final.scorePos;
    lastPrediction = final.activePred;
    
    updateUI();
}

/**
 * UI & INTERACTION
 */
function updateUI() {
    const strip = document.getElementById('history-strip');
    strip.innerHTML = '';
    [...history].reverse().slice(0, 20).forEach(n => strip.appendChild(createBall(n, 'mini-ball')));

    const predSet = document.getElementById('prediction-set');
    predSet.innerHTML = '';
    if (history.length < 3) {
        predSet.innerHTML = '<div style="opacity:.5">Awaiting Data...</div>';
    } else {
        lastPrediction.forEach(n => predSet.appendChild(createBall(n)));
    }

    document.getElementById('total-wins').innerText = currentWins;
    const rate = history.length > 3 ? ((currentWins / (history.length - 3)) * 100).toFixed(1) : 0;
    document.getElementById('win-rate').innerText = rate + "%";
    document.getElementById('algorithm-status').innerText = "Optimized";
    document.getElementById('best-params').innerText = `W:${currentBestConfig.WINDOW_SIZE} NW:${currentBestConfig.NEIGHBOR_WEIGHT}`;
    
    // Confidence calculation
    const scores = calculateScores(history, currentBestConfig, lastPrediction);
    const vals = [...scores.values()];
    const conf = Math.min(99, Math.round((Math.max(...vals) / (vals.reduce((a,b)=>a+b)/37)) * 25));
    document.getElementById('confidence-val').innerText = conf + "%";

    const posEl = document.getElementById('score-positions');
    const displayPos = [...new Set(winnerScorePositions.filter(p => p <= 18))].slice(-3);///
    posEl.innerText = displayPos.length ? displayPos.map(p => `#${p}`).join(", ") : "–";
}

function addSpin(num) {
    history.push(num);
    saveData();
    autoTune();
}

function undo() {
    history.pop();
    saveData();
    autoTune();
}

function resetData() {
    if (confirm("Clear all?")) { history = []; saveData(); autoTune(); updateUI(); }
}

function buildGrid() {
    const g = document.getElementById('number-grid');
    for (let i = 1; i <= 36; i++) {
        const b = document.createElement('button');
        b.innerText = i; b.className = 'grid-btn';
        b.style.background = REDS.includes(i) ? 'var(--red)' : '#334155';
        b.onclick = () => addSpin(i);
        g.appendChild(b);
    }
}

function createBall(n, cls='ball') {
    const d = document.createElement('div');
    d.className = `${cls} ${n===0?'zero':REDS.includes(n)?'red':'black'}`;
    d.innerText = n;
    return d;
}

function addRandom() { addSpin(Math.floor(Math.random() * 37)); }
function sim10() { for(let i=0; i<10; i++) addRandom(); }
function saveData() { localStorage.setItem('roulette_pro_hist', JSON.stringify(history)); }
function loadData() {
    history = JSON.parse(localStorage.getItem('roulette_pro_hist') || "[]");
    autoTune();
}

document.addEventListener('DOMContentLoaded', () => {
    buildGrid();
    loadData();
});
</script>
</body>
</html>