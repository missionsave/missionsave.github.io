<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>French Roulette – Robust Statistical Predictor</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      background: #121212;
      color: #e0e0e0;
    }
    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
      color: #fff;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 6px;
      margin-bottom: 1rem;
    }
    button.num {
      padding: 10px 0;
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95rem;
      background: #252525;
      color: #eee;
      transition: all 0.1s;
      font-weight: 500;
    }
    button.num:hover { background: #444; border-color: #666; }
    button.num:active { transform: scale(0.96); }
    button.zero { background: #0a5c0a; border-color: #0f7a0f; }
    button.red { color: #ff6b6b; } 
    
    .panel {
      margin-bottom: 1rem;
      padding: 15px;
      border-radius: 8px;
      background: #1e1e1e;
      border: 1px solid #333;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .label {
      font-weight: 600;
      margin-bottom: 8px;
      display: block;
      color: #bbb;
    }
    .history {
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      word-wrap: break-word;
      color: #aaa;
      line-height: 1.4;
    }
    .predictions li {
      margin-bottom: 6px;
      padding: 6px;
      background: #2a2a2a;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pred-num { font-size: 1.1rem; font-weight: bold; width: 30px; }
    .pred-stats { font-size: 0.75rem; color: #888; flex-grow: 1; text-align: right; }
    
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      font-size: 0.85rem;
      margin-top: 10px;
    }
    .stat-box {
      background: #252525;
      padding: 8px;
      border-radius: 4px;
    }
    .stat-val { font-weight: bold; color: #fff; display: block; margin-top: 2px;}

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 0.8rem;
    }
    input[type="number"] {
      width: 60px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #111;
      color: #eee;
    }
    button.ctrl {
      padding: 5px 10px;
      background: #333;
      border: none;
      color: #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
    button.ctrl:hover { background: #555; color: #fff; }

    .badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      background: #333;
      font-size: 0.75rem;
      margin-left: 6px;
      color: #888;
    }
    .red-txt { color: #ff6b6b; }
    .black-txt { color: #eee; }
    .green-txt { color: #4caf50; }
  </style>
</head>
<body>
  <h1>French Roulette – Robust Predictor</h1>

  <div class="panel">
    <div class="label">Input History:</div>
    <div class="grid" id="buttons-container"></div>
    
    <div class="controls">
      <button class="ctrl" id="undo-btn">Undo</button>
      <button class="ctrl" id="clear-btn">Reset</button>
      <label style="font-size:0.8rem; color:#888;">
        Window: <input type="number" id="max-history" min="10" value="200" />
      </label>
    </div>

    <div class="history">
      <span class="label" style="display:inline;">Log:</span>
      <span id="history-display">(waiting for data...)</span>
    </div>
  </div>


  <div class="panel">
    <div class="label">
      Top 5 Probabilities
      <span class="badge" id="count-badge">0 spins</span>
    </div>
    <ul id="predictions" class="predictions"></ul>
    <div style="font-size:0.75rem; color:#555; margin-top:8px;">
      Algorithm: Vector Wheel Bias + Sector Weight + Pattern Matcher + N-Grams + Z-Score Freq.
    </div>
  </div>


  <div class="panel">
    <div class="label">Live Statistics</div>
    <div class="stats-grid">
      <div class="stat-box">
        Hot Numbers (Z-Score)
        <span class="stat-val" id="stat-hot">-</span>
      </div>
      <div class="stat-box">
        Cold Numbers
        <span class="stat-val" id="stat-cold">-</span>
      </div>
      <div class="stat-box">
        Dominant Sector
        <span class="stat-val" id="stat-sector">-</span>
      </div>
    </div>
  </div>
  <script>
    // --- CONSTANTS & DATA ---

    const ALL = Array.from({ length: 37 }, (_, i) => i);
    
    // RED numbers in standard roulette
    const REDS = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
    
    // Wheel Order (Clockwise starting 0)
    const WHEEL = [
      0, 32, 15, 19, 4, 21, 2, 25, 17, 34,
      6, 27, 13, 36, 11, 30, 8, 23, 10, 5,
      24, 16, 33, 1, 20, 14, 31, 9, 22, 18,
      29, 7, 28, 12, 35, 3, 26
    ];
    
    // Map number to index on wheel (0..36)
    const wheelIdx = {};
    WHEEL.forEach((n, i) => wheelIdx[n] = i);

    // SECTORS
    const SECTORS = {
      "Voisins": [22,18,29,7,28,12,35,3,26,0,32,15,19,4,21,2,25],
      "Tiers": [27,13,36,11,30,8,23,10,5,24,16,33],
      "Orphelins": [1,20,14,31,9,17,34,6]
    };

    let history = [];

    // --- UI INIT ---

    const buttonsContainer = document.getElementById("buttons-container");
    const historyDisplay = document.getElementById("history-display");
    const predictionsList = document.getElementById("predictions");
    const countBadge = document.getElementById("count-badge");
    const statHot = document.getElementById("stat-hot");
    const statCold = document.getElementById("stat-cold");
    const statSector = document.getElementById("stat-sector");

    function createButtons() {
      for (let n = 0; n <= 36; n++) {
        const btn = document.createElement("button");
        btn.textContent = n;
        const isRed = REDS.includes(n);
        btn.className = "num" + (n === 0 ? " zero" : isRed ? " red" : "");
        btn.addEventListener("click", () => addNumber(n));
        buttonsContainer.appendChild(btn);
      }
    }

    // --- STATE MANAGEMENT ---

    function addNumber(n) {
      const maxHistory = parseInt(document.getElementById("max-history").value, 10) || 200;
      history.push(n);
      if (history.length > maxHistory) {
        history = history.slice(history.length - maxHistory);
      }
      updateView();
    }

    document.getElementById("undo-btn").addEventListener("click", () => {
      history.pop();
      updateView();
    });

    document.getElementById("clear-btn").addEventListener("click", () => {
      history = [];
      updateView();
    });

    // --- ADVANCED MATH HELPERS ---

    // 1. Vector Distance on Wheel (Circular Geometry)
    // Returns a score 0.0 to 1.0 based on how close 'target' is to 'angle'
    function getCircularLikelihood(targetNum, targetAngleRad) {
      // Get angle of the target number
      const numIdx = wheelIdx[targetNum];
      const numAngle = (numIdx / 37) * 2 * Math.PI;
      
      // Cosine similarity 
      const dist = Math.cos(numAngle - targetAngleRad); 
      // Map -1..1 to 0..1 (approx)
      return (dist + 1) / 2;
    }

    // 2. Pattern Matcher (Longest Common Suffix)
    function getPatternScore(hist, num) {
      if (hist.length < 10) return 0;
      const limit = 6; // Max pattern depth to check
      let matchScore = 0;
      
      // Check patterns of length 2 to limit
      for (let len = 1; len <= limit; len++) {
        if (hist.length < len + 1) break;
        const seq = hist.slice(hist.length - len);
        
        // Search history for this sequence (excluding the very last instance which is current)
        for (let i = 0; i < hist.length - len - 1; i++) {
           let match = true;
           for (let k = 0; k < len; k++) {
             if (hist[i+k] !== seq[k]) { match = false; break; }
           }
           if (match) {
             // The number AFTER the sequence
             const after = hist[i + len];
             if (after === num) {
               matchScore += (len * len); // Quadratic weight for longer matches
             }
           }
        }
      }
      return matchScore;
    }

    // --- PREDICTION ENGINE ---

    function computePrediction(args) {
      if (!args || args.length < 5) return [];

      const N = args.length;
      
      // 1. Z-Score Frequency Analysis
      const freq = {};
      ALL.forEach(n => freq[n] = 0);
      args.forEach(n => freq[n]++);
      
      const mean = N / 37;
      // Standard Deviation for binomial distribution approx
      const stdDev = Math.sqrt(N * (1/37) * (36/37)); 
      
      const zScores = {};
      ALL.forEach(n => {
        zScores[n] = (freq[n] - mean) / (stdDev || 1);
      });

      // 2. Vector-Based Wheel Bias (Center of Gravity)
      // Convert recent history to unit vectors
      let sinSum = 0, cosSum = 0, weightSum = 0;
      const decay = 0.96; // Recent spins matter more for bias
      
      args.forEach((n, i) => {
        const w = Math.pow(decay, N - 1 - i);
        const idx = wheelIdx[n];
        const rad = (idx / 37) * 2 * Math.PI;
        sinSum += Math.sin(rad) * w;
        cosSum += Math.cos(rad) * w;
        weightSum += w;
      });
      
      const avgSin = sinSum / weightSum;
      const avgCos = cosSum / weightSum;
      const avgAngle = Math.atan2(avgSin, avgCos); // The "Hot Angle"

      // 3. Sector Analysis
      const sectorScores = { "Voisins": 0, "Tiers": 0, "Orphelins": 0 };
      args.slice(-20).forEach(n => {
         for(let k in SECTORS) {
           if(SECTORS[k].includes(n)) sectorScores[k]++;
         }
      });
      let totalSec = 0;
      for(let k in sectorScores) totalSec += sectorScores[k];
      
      // 4. Transitions (Markov)
      const last = args[N-1];
      const prev = N > 1 ? args[N-2] : null;
      const transitions = {};
      const bigramKey = prev !== null ? `${prev}_${last}` : null;
      const trigramCounts = {};
      
      // Build transitions
      for(let i=2; i<N; i++) {
        const p = args[i-1];
        const pp = args[i-2];
        const curr = args[i];
        
        if (!transitions[p]) transitions[p] = {};
        transitions[p][curr] = (transitions[p][curr] || 0) + 1;
        
        const key = `${pp}_${p}`;
        if (!trigramCounts[key]) trigramCounts[key] = {};
        trigramCounts[key][curr] = (trigramCounts[key][curr] || 0) + 1;
      }

      // --- AGGREGATE SCORES ---
      
      const scores = [];
      
      // Weights
      const W_FREQ = 0.15;
      const W_VECTOR = 0.25;  // Wheel bias
      const W_TRANS = 0.30;   // Markov
      const W_PATTERN = 0.20; // Longest Match
      const W_SECTOR = 0.10;

      ALL.forEach(num => {
        // A. Frequency Score (Sigmoid of Z-score)
        const z = zScores[num];
        const sFreq = 1 / (1 + Math.exp(-z)); // 0..1

        // B. Vector/Wheel Score
        const sVector = getCircularLikelihood(num, avgAngle);

        // C. Transition Score
        let transRaw = (transitions[last]?.[num] || 0);
        if (bigramKey) transRaw += (trigramCounts[bigramKey]?.[num] || 0) * 2;
        const sTrans = Math.min(transRaw, 5) / 5; // Normalize cap

        // D. Pattern Score
        const patRaw = getPatternScore(args, num);
        const sPattern = Math.min(patRaw, 10) / 10; 

        // E. Sector Score
        let sSector = 0;
        for(let k in SECTORS) {
          if (SECTORS[k].includes(num)) {
            sSector = sectorScores[k] / (totalSec || 1);
          }
        }

        const total = 
          (sFreq * W_FREQ) + 
          (sVector * W_VECTOR) + 
          (sTrans * W_TRANS) + 
          (sPattern * W_PATTERN) +
          (sSector * W_SECTOR);

        scores.push({
          n: num,
          total: total,
          z: z,
          details: { V: sVector, T: sTrans, P: sPattern }
        });
      });

      return scores.sort((a, b) => b.total - a.total);
    }

    // --- VIEW UPDATE ---

    function updateView() {
      // 1. History
      if (history.length === 0) {
        historyDisplay.textContent = "(waiting for data...)";
        predictionsList.innerHTML = "";
        countBadge.textContent = "0 spins";
        statHot.textContent = "-";
        statCold.textContent = "-";
        statSector.textContent = "-";
        return;
      }

      const displayHist = history.map(n => {
        const c = n === 0 ? 'green-txt' : REDS.includes(n) ? 'red-txt' : 'black-txt';
        return `<span class="${c}">${n}</span>`;
      }).join(", ");
      historyDisplay.innerHTML = displayHist;
      countBadge.textContent = `${history.length} spins`;

      // 2. Calculations
      const ranked = computePrediction(history);
      
      // 3. Predictions UI
      predictionsList.innerHTML = "";
      if (history.length < 5) {
        predictionsList.innerHTML = "<li style='color:#888'>Enter at least 5 numbers...</li>";
      } else {
        ranked.slice(0, 5).forEach((item, i) => {
          const li = document.createElement("li");
          const colorClass = item.n === 0 ? "green-txt" : REDS.includes(item.n) ? "red-txt" : "black-txt";
          
          li.innerHTML = `
            <div class="pred-num ${colorClass}">${item.n}</div>
            <div class="pred-stats">
               Score: <strong>${item.total.toFixed(3)}</strong> 
               (Seq:${item.details.T.toFixed(2)} | Wheel:${item.details.V.toFixed(2)} | Pat:${item.details.P.toFixed(2)})
            </div>
          `;
          predictionsList.appendChild(li);
        });
      }

      // 4. Update Stats Dashboard
      if (history.length > 5) {
        // Hot (High Z-Score)
        const hot = ranked.slice().sort((a,b) => b.z - a.z).slice(0,3).map(x=>x.n).join(", ");
        statHot.textContent = hot;
        
        // Cold (Low Z-Score)
        const cold = ranked.slice().sort((a,b) => a.z - b.z).slice(0,3).map(x=>x.n).join(", ");
        statCold.textContent = cold;

        // Sectors
        const sectorCounts = { "Voisins": 0, "Tiers": 0, "Orphelins": 0 };
        history.slice(-20).forEach(n => {
          for(let k in SECTORS) if(SECTORS[k].includes(n)) sectorCounts[k]++;
        });
        const sortedSec = Object.entries(sectorCounts).sort((a,b)=>b[1]-a[1]);
        statSector.textContent = `${sortedSec[0][0]} (${Math.round(sortedSec[0][1]/20*100)}%)`;
      }
    }

    createButtons();
    updateView();
  </script>
</body>
</html>