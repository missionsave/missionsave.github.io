<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Adaptive Breakout v3</title>
<style>
:root {
    --bg: #0f172a; --panel: #1e293b; --border: #334155; --text: #e2e8f0;
    --muted: #94a3b8; --accent: #3b82f6; --red: #ef4444; --green: #22c55e;
    --gold: #f59e0b; 
}
body {
    font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg);
    color: var(--text); margin: 0; padding: 15px;
    display: flex; flex-direction: column; align-items: center;
}
.container { width: 100%; max-width: 800px; display: flex; flex-direction: column; gap: 15px; }

/* HUD */
.card { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
.hud-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px; }
.hud-title { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--muted); font-weight: 700; }
.big-stat { font-size: 28px; font-weight: 800; color: var(--accent); line-height: 1; }
.sub-stat { font-size: 12px; color: var(--muted); margin-top: 4px; }

/* Predictions */
.ball-row { display: flex; gap: 8px; flex-wrap: wrap; }
.ball {
    width: 44px; height: 44px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-weight: 700; font-size: 18px;
    box-shadow: inset 0 -3px 3px rgba(0,0,0,0.3);
    border: 2px solid rgba(255,255,255,0.1);
    transition: transform 0.2s;
}
.ball:hover { transform: scale(1.1); }
.ball.zero { background: var(--green); color: white; }
.ball.red { background: var(--red); color: white; }
.ball.black { background: #334155; color: white; }
.mini-ball { width: 28px; height: 28px; font-size: 11px; }

/* Analysis Bar */
.strategy-tag { 
    display: inline-block; padding: 4px 8px; border-radius: 4px; 
    font-size: 11px; font-weight: bold; margin-left: 8px;
    background: rgba(255,255,255,0.05); color: var(--muted);
}
.strategy-tag.active { background: var(--gold); color: #000; box-shadow: 0 0 10px rgba(245, 158, 11, 0.4); }

/* Input Grid */
.input-grid {
    display: grid; grid-template-columns: repeat(12, 1fr); gap: 4px;
    background: #000; padding: 10px; border-radius: 12px;
}
.grid-btn {
    aspect-ratio: 1; border-radius: 4px; border: none;
    font-weight: bold; color: white; cursor: pointer;
    font-size: 14px; display: flex; align-items: center; justify-content: center;
    transition: filter 0.1s;
}
.grid-btn:active { filter: brightness(1.2); }
.zero-btn { grid-column: span 12; aspect-ratio: auto; height: 40px; background: var(--green); margin-bottom: 4px; }

/* Controls */
.controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
.btn-ctrl { padding: 14px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; color: white; }
.btn-undo { background: #475569; }
.btn-reset { background: var(--red); }
.btn-sim { background: var(--accent); }

@media (max-width: 600px) {
    .input-grid { grid-template-columns: repeat(6, 1fr); }
    .zero-btn { grid-column: span 6; }
}
</style>
</head>
<body>

<div class="container">

    <div class="card">
        <div class="hud-header">
            <div>
                <div class="hud-title">Current Breakout Prediction</div>
                <div id="prediction-set" class="ball-row" style="margin-top:10px; min-height:44px;"></div>
            </div>
            <div style="text-align: right;">
                <div class="hud-title">Backtest Accuracy</div>
                <div id="accuracy-disp" class="big-stat">--%</div>
                <div id="hits-disp" class="sub-stat">0 Hits / 0 Spins</div>
            </div>
        </div>
        
        <div style="border-top: 1px solid var(--border); padding-top: 15px; margin-top: 5px;">
            <div class="hud-title" style="margin-bottom:8px;">Active Strategy (Auto-Selected)</div>
            <div id="strategies-container">
                <span class="strategy-tag" id="tag-hot">HOT FLOW</span>
                <span class="strategy-tag" id="tag-sector">SECTOR BIAS</span>
                <span class="strategy-tag" id="tag-repeat">REPEATERS</span>
                <span class="strategy-tag" id="tag-balance">EQUILIBRIUM</span>
            </div>
            <div id="logic-desc" style="font-size: 12px; color: var(--accent); margin-top: 8px;">
                Waiting for data...
            </div>
        </div>
    </div>

    <div class="card" style="padding: 10px; overflow-x: auto;">
        <div id="history-strip" class="ball-row" style="flex-wrap: nowrap;"></div>
    </div>

    <div class="input-grid">
        <button class="zero-btn grid-btn" onclick="addSpin(0)">0</button>
        <div id="number-buttons" style="display: contents;"></div>
    </div>

    <div class="controls">
        <button class="btn-ctrl btn-undo" onclick="undo()">UNDO</button>
        <button class="btn-ctrl btn-reset" onclick="resetData()">RESET</button>
        <button class="btn-ctrl btn-sim" onclick="sim10()">SIMULATE 10</button>
    </div>

</div>

<script>
/* ===========================
   CONSTANTS & SETUP
=========================== */
const WHEEL = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
const REDS  = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];

// The 4 Core Strategies to Race
const STRATEGIES = [
    { id: 'hot',     name: 'HOT FLOW',    window: 12, neighbors: 0, decay: 1.1 }, // Standard Hot numbers
    { id: 'sector',  name: 'SECTOR BIAS', window: 18, neighbors: 2, decay: 1.05}, // Physical Dealer Signature
    { id: 'repeat',  name: 'REPEATERS',   window: 6,  neighbors: 0, decay: 1.5 }, // Immediate Repeats (High decay)
    { id: 'balance', name: 'EQUILIBRIUM', window: 36, neighbors: 1, decay: 1.0 }  // Long term smoothing
];

let history = [];
let activeStrategyId = 'sector'; // Default
let stats = { total: 0, hits: 0 };
let currentPredictions = [];

/* ===========================
   LOGIC ENGINE
=========================== */

// 1. Core Scoring Function (The "Brain")
function calculateScores(data, cfg) {
    let scores = new Map();
    WHEEL.forEach(n => scores.set(n, 0));

    // Slice the data window
    const chunk = data.slice(-cfg.window);

    chunk.forEach((val, idx) => {
        // Recency weight
        let weight = Math.pow(cfg.decay, idx + 1);
        
        // Add to main number
        scores.set(val, scores.get(val) + weight);

        // Add to neighbors (Sector Logic)
        if (cfg.neighbors > 0) {
            const centerIdx = WHEEL.indexOf(val);
            for (let r = 1; r <= cfg.neighbors; r++) {
                const right = WHEEL[(centerIdx + r) % 37];
                const left  = WHEEL[(centerIdx - r + 37) % 37];
                // Neighbors get 50% of the weight
                scores.set(right, scores.get(right) + (weight * 0.5));
                scores.set(left,  scores.get(left)  + (weight * 0.5));
            }
        }
    });

    return [...scores.entries()].sort((a, b) => b[1] - a[1]);
}

// 2. The "Backtest Breakout" Selector
function selectBestStrategy() {
    if (history.length < 10) {
        // Not enough data, stick to Sector
        return STRATEGIES.find(s => s.id === 'sector');
    }

    // We simulate the last 15 spins for each strategy
    let scores = STRATEGIES.map(strat => {
        let hits = 0;
        // Test previous spins (up to 15 back)
        const testCount = Math.min(15, history.length - 5);
        
        for (let i = 0; i < testCount; i++) {
            // Target index to predict
            const targetIdx = history.length - 1 - i;
            const target = history[targetIdx];
            
            // Historical data available at that moment
            const pastData = history.slice(0, targetIdx);
            
            // Get prediction from strategy
            const ranked = calculateScores(pastData, strat);
            const top5 = ranked.slice(0, 5).map(e => e[0]);
            
            if (top5.includes(target)) hits++;
        }
        return { strat, hits };
    });

    // Sort by most hits recently
    scores.sort((a, b) => b.hits - a.hits);
    
    // Return the winner
    return scores[0].strat;
}

// 3. Main Update Loop
function updatePrediction() {
    // A. Find which strategy is currently "Breaking Out" (Winning)
    const bestStrat = selectBestStrategy();
    activeStrategyId = bestStrat.id;

    // B. Generate Prediction using that strategy
    const ranked = calculateScores(history, bestStrat);
    currentPredictions = ranked.slice(0, 5).map(e => e[0]);

    // C. Update Stats (Did we win last spin?)
    if (history.length > 0) {
        // Note: Real stats tracking requires storing previous predictions.
        // For this simplified version, we calculate "paper wins" on the active strategy
    }
    
    updateUI(bestStrat);
}

/* ===========================
   UI & INTERACTION
=========================== */
function updateUI(activeStrat) {
    // 1. Render Predictions
    const container = document.getElementById('prediction-set');
    container.innerHTML = '';
    currentPredictions.forEach(n => container.appendChild(createBall(n)));

    // 2. Render History
    const strip = document.getElementById('history-strip');
    strip.innerHTML = '';
    [...history].reverse().slice(0, 20).forEach(n => strip.appendChild(createBall(n, 'mini-ball')));

    // 3. Highlight Active Strategy
    STRATEGIES.forEach(s => {
        const el = document.getElementById(`tag-${s.id}`);
        if (s.id === activeStrat.id) {
            el.classList.add('active');
        } else {
            el.classList.remove('active');
        }
    });

    // 4. Update Text
    document.getElementById('logic-desc').innerHTML = 
        `Detected Trend: <b>${activeStrat.name}</b> (Window: ${activeStrat.window}, Neighbors: ${activeStrat.neighbors})`;

    // 5. Update Stats (Simple mock calculation for display)
    if (stats.total > 0) {
        let pct = Math.round((stats.hits / stats.total) * 100);
        document.getElementById('accuracy-disp').innerText = `${pct}%`;
        document.getElementById('hits-disp').innerText = `${stats.hits} Hits / ${stats.total} Spins`;
    }
}

function createBall(n, type='ball') {
    const div = document.createElement('div');
    const color = n === 0 ? 'zero' : REDS.includes(n) ? 'red' : 'black';
    div.className = `${type} ${color}`;
    div.innerText = n;
    return div;
}

function addSpin(n) {
    // Check if previous prediction hit (before adding new number)
    if (history.length > 5 && currentPredictions.length > 0) {
        stats.total++;
        if (currentPredictions.includes(n)) stats.hits++;
    }

    history.push(n);
    save();
    updatePrediction();
}

function undo() {
    history.pop();
    // Reduce stats roughly (not perfect undo but functional)
    if (stats.total > 0) stats.total--;
    save();
    updatePrediction();
}

function resetData() {
    if(confirm("Reset History?")) {
        history = [];
        stats = { total: 0, hits: 0 };
        currentPredictions = [];
        save();
        updatePrediction();
        document.getElementById('accuracy-disp').innerText = "--%";
    }
}

function sim10() {
    for(let i=0; i<10; i++) {
        addSpin(Math.floor(Math.random()*37));
    }
}

function save() {
    localStorage.setItem('roulette_v3_hist', JSON.stringify(history));
    localStorage.setItem('roulette_v3_stats', JSON.stringify(stats));
}

// Init
document.addEventListener('DOMContentLoaded', () => {
    // Generate Grid
    const grid = document.getElementById('number-buttons');
    for (let i = 1; i <= 36; i++) {
        const btn = document.createElement('button');
        btn.className = 'grid-btn';
        btn.style.background = REDS.includes(i) ? 'var(--red)' : '#334155';
        btn.innerText = i;
        btn.onclick = () => addSpin(i);
        grid.appendChild(btn);
    }

    // Load Data
    const savedHist = localStorage.getItem('roulette_v3_hist');
    const savedStats = localStorage.getItem('roulette_v3_stats');
    
    if (savedHist) history = JSON.parse(savedHist);
    if (savedStats) stats = JSON.parse(savedStats);

    updatePrediction();
});
</script>
</body>
</html>