<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>AI Prediction & Trading Signal</title>
  <style>
    body { font-family: Arial, sans-serif; background: #ffffff; color: #333131; padding: 20px; }
    table { border-collapse: collapse; margin-bottom: 30px; width: 100%; max-width: 900px; }
    th, td { border: 1px solid #444; padding: 8px 12px; text-align: right; }
    th { background: #c96767; }
    caption { text-align: left; font-size: 1.2em; margin-bottom: 5px; }
    .pred { font-weight: bold; color: rgb(47, 235, 47); }
    .pred.negative { color: #f33; }
    .current { background: #eefffe; font-weight: bold; }
    .pos { color: rgb(47, 235, 47); }
    .neg { color: #f33; }
    .signal-buy { color: rgb(47, 235, 47); font-weight: bold; }
    .signal-sell { color: #f33; font-weight: bold; }
  </style>
</head>
<body><div style="font-family: Arial, sans-serif; font-size:14px; line-height:1.5; color:#333; background:#f9f9f9; padding:12px; border-radius:8px; border:1px solid #ddd;">
To raise the maximum funds to build our greenhouses and provide healthy meals to people with little or no access to food, Daniel Chanfana Santos, founder of Missionsave, developed this app using artificial intelligence to predict the movement of the four most consistent cryptocurrencies. An automated trading robot is under development and will be ready soon—then you can register and start earning too. Alternatively, visit this page at 00:00 UTC to manually make your trades for the day.
</div>
<br>
  <div id="idtime"></div>
  <div id="tables"></div>

<script>
{
  const urlParams = new URLSearchParams(window.location.search);
  const isExport = urlParams.has("export");

  const now = new Date(),
    utcH = now.getUTCHours(),
    utcM = now.getUTCMinutes(),
    end = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()+1),
    diff = end - now,
    hLeft = Math.floor(diff/36e5),
    mLeft = Math.floor(diff%36e5/6e4);
  document.getElementById("idtime").textContent =
    `UTC: ${utcH.toString().padStart(2,'0')}:${utcM.toString().padStart(2,'0')} | Time until end of the day: ${hLeft}h ${mLeft}m`;

//   const symbols_ = [
//     { name: 'Bitcoin', pair: 'BTCUSDT' },
//     { name: 'Ethereum', pair: 'ETHUSDT' },
//     { name: 'Doge', pair: 'DOGEUSDT' },
//     // { name: 'BNB', pair: 'BNBUSDT' },
//     { name: 'XRP', pair: 'XRPUSDT' },
//     { name: 'Solana', pair: 'SOLUSDT' }
//   ];
const symbols_ = [
  { name: 'Bitcoin', pair: 'BTCUSDT' },       // +147% YTD, huge daily volume
  { name: 'Ethereum', pair: 'ETHUSDT' },      // +87% YTD, strong DeFi/NFT demand
  { name: 'Solana', pair: 'SOLUSDT' },        // Major ecosystem growth, high liquidity
  { name: 'XRP', pair: 'XRPUSDT' },           // Regulatory clarity boosting adoption
//   { name: 'Avalanche', pair: 'AVAXUSDT' },    // Rising DeFi & gaming activity
//   { name: 'Cardano', pair: 'ADAUSDT' },       // Smart contract adoption uptick
//     { name: 'Doge', pair: 'DOGEUSDT' },
// //   { name: 'Kaspa', pair: 'KASUSDT' },         // Fast-growing PoW chain, surging price
//   { name: 'Sui', pair: 'SUIUSDT' },           // Layer 1 with strong dev traction
//   { name: 'Celestia', pair: 'TIAUSDT' },      // Modular blockchain innovation
//   { name: 'Kava', pair: 'KAVAUSDT' }          // Bridging TradFi & Web3, rising volumes
];
const lb=0;
  const interval = '1d';
  const historyLength = 10+lb;
  const RERUNS = 8*2;
  const TRAIN_ITER = 100*4;

  async function fetchData(symbol) {
    const url = `https://data-api.binance.vision/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${historyLength}`;
    const res = await fetch(url);
    return res.json();
  }

  function formatNum(num, decimals = 2) {
    return parseFloat(num).toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
  }

  function normalizePerFeature(data) {
    const features = data[0].length;
    const mins = Array(features).fill(Infinity);
    const maxs = Array(features).fill(-Infinity);
    data.forEach(row => row.forEach((v,i)=>{ if(v<mins[i]) mins[i]=v; if(v>maxs[i]) maxs[i]=v; }));
    const normalized = data.map(row => row.map((v,i)=>(v-mins[i])/(maxs[i]-mins[i]||1)));
    return { normalized, mins, maxs };
  }

  function denormalizeRow(row, mins, maxs) {
    return row.map((v, i) => v * (maxs[i] - mins[i]) + mins[i]);
  }

  function trainOnce(rows) {
    const { normalized, mins, maxs } = normalizePerFeature(rows);
    const net = new brain.recurrent.LSTMTimeStep({
      inputSize: 4,
      hiddenLayers: [16],
      outputSize: 4
    });
    net.train(normalized, { iterations: TRAIN_ITER, learningRate: 0.01 });
    const lastSeq = normalized.slice(-1);
    const predictionNorm = net.run(lastSeq);
    return denormalizeRow(predictionNorm, mins, maxs);
  }

  function median(arr) {
    const s = [...arr].sort((a,b)=>a-b);
    const m = Math.floor(s.length/2);
    return s.length % 2 ? s[m] : (s[m-1]+s[m])/2;
  }

  function trainAndPredictMedian(rows, runs=RERUNS) {
    const highs=[], lows=[], closes=[], vols=[];
    for(let i=0;i<runs;i++){
      const p=trainOnce(rows);
      highs.push(p[0]); lows.push(p[1]); closes.push(p[2]); vols.push(p[3]);
    }
    return [median(highs), median(lows), median(closes), median(vols)];
  }
  const atleast=0.2;
  function generateSignal(predClose, prevClose) {
    const diffPct = ((predClose - prevClose) / prevClose) * 100;
    let signal, entry, sl, tp;
    if (diffPct > atleast) {
      signal = 'BUY'; entry = prevClose;
      sl = prevClose*0.98; tp = prevClose*1.03;
    } else if (diffPct < -atleast) {
      signal = 'SELL'; entry = prevClose;
      sl = prevClose*1.02; tp = prevClose*0.97;
    } else {
      signal = 'HOLD'; entry = prevClose; sl = null; tp = null;
    }
    return { signal, diffPct, entry, sl, tp };
  }

  const portfolio = [];

  async function main() {
    const container = document.getElementById('tables');
    const results = [];

    for (const coin of symbols_) {
      var rawData = await fetchData(coin.pair);
	  if(lb>0)rawData = rawData.slice(0, -lb);
	  console.log(rawData);
      const historicalData = rawData.slice(0, -1);
	//   console.log(historicalData);
      const currentCandle = rawData[rawData.length - 1];
      const last7 = historicalData.slice(-7);

      const rows = historicalData.map(c => [
        parseFloat(c[2]), parseFloat(c[3]), parseFloat(c[4]), parseFloat(c[5])
      ]);

      const [predHigh, predLow, predClose] = trainAndPredictMedian(rows, RERUNS);
      const prevClose = parseFloat(historicalData[historicalData.length - 1][4]);
      const currentClose = parseFloat(currentCandle[4]);
      const changePctCurrent = ((currentClose - prevClose)/prevClose)*100;

      const { signal, diffPct, entry, sl, tp } = generateSignal(predClose, prevClose);

      const maxWinPct = signal==='BUY'
        ? ((tp-entry)/entry)*100
        : signal==='SELL' ? ((entry-tp)/entry)*100 : 0;

      const maxLossPct = signal==='BUY'
        ? ((entry-sl)/entry)*100
        : signal==='SELL' ? ((sl-entry)/entry)*100 : 0;

      const expectedRaw = signal==='BUY'
        ? ((predClose-entry)/entry)*100
        : signal==='SELL' ? ((entry-predClose)/entry)*100 : 0;

      const expectedWinPct = Math.max(0, Math.min(expectedRaw, maxWinPct));

	  const prevDate = new Date(historicalData[historicalData.length - 1][0]).toISOString().split("T")[0];
      const record = {
        name: coin.name,
        pair: coin.pair,
        prevDate, 
        signal,
        prevClose,
        predClose,
        diffPct,
        entry,
        stopLoss: sl,
        takeProfit: tp,
        maxWinPct,
        maxLossPct,
        expectedWinPct
      };
      results.push(record);
      portfolio.push(record);

      if (!isExport) {
        // render tables as before
        let html = `<table>
          <caption>${coin.name} (${coin.pair})</caption>
          <thead><tr><th><span class="notranslate">Date</span></th><th><span class="notranslate">High</span></th><th><span class="notranslate">Low</span></th><th><span class="notranslate">Close</span></th><th>% Change vs Prev</th></tr></thead><tbody>`;
        last7.forEach((candle, idx) => {
          const date = `${new Date(candle[0]).toISOString().split('T')[0]} ${String(new Date(candle[0]).getUTCHours()).padStart(2,'0')}`;
          const change = idx===0?null:((parseFloat(candle[4])-parseFloat(last7[idx-1][4]))/parseFloat(last7[idx-1][4]))*100;
          html += `<tr>
            <td style="text-align:left">${date}</td>
            <td>${formatNum(candle[2])}</td>
            <td>${formatNum(candle[3])}</td>
            <td>${formatNum(candle[4])}</td>
            <td>${change!==null?`<span class="${change>=0?'pos':'neg'}">${formatNum(change)}%</span>`:'-'}</td>
          </tr>`;
        });
        const currentDate = `${new Date(currentCandle[0]).toISOString().split('T')[0]} ${String(new Date(currentCandle[0]).getUTCHours()).padStart(2,'0')}`;
        html += `<tr class="current">
          <td style="text-align:left">${currentDate} (Current)</td>
          <td>${formatNum(currentCandle[2])}</td>
          <td>${formatNum(currentCandle[3])}</td>
          <td>${formatNum(currentCandle[4])}</td>
          <td><span class="${changePctCurrent>=0?'pos':'neg'}">${formatNum(changePctCurrent)}%</span></td>
        </tr>`;
        html += `</tbody><tfoot><tr><td colspan="5" class="${signal==='BUY'?'signal-buy':signal==='SELL'?'signal-sell':''}">
          Signal: ${signal} | Median Predicted Close: ${formatNum(predClose)} USDT (${diffPct>=0?'+':''}${formatNum(diffPct)}%)<br>
          ${signal!=='HOLD'
            ? `Entry: ${formatNum(entry)} | Stop Loss: ${sl?formatNum(sl):'-'} | Take Profit: ${tp?formatNum(tp):'-'}<br>
               Est. Max Win: ${formatNum(maxWinPct)}% | Est. Max Loss: ${formatNum(maxLossPct)}% | Est. Expected Win: ${formatNum(expectedWinPct)}%`
            : 'No trade suggested'}
        </td></tr></tfoot></table>`;
        container.innerHTML += html;
      }
    }

    if (isExport) {
      const blob = new Blob([JSON.stringify(results, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "signals.json"; a.click();
      URL.revokeObjectURL(url);


	 // Clear the page
		// document.body.innerHTML = "";

		// // Show JSON in <pre> so PHP can read it
		// const pre = document.createElement("pre");
		// pre.textContent = JSON.stringify(results, null, 2);
		// document.body.appendChild(pre);

		// return; // stop here

//   document.body.innerHTML = ""; // hide tables/divs
//   document.body.textContent = JSON.stringify(results, null, 2);
//   return; // stop further rendering


    } else {
      alloc();
    }
  }

  const budget = 100;
  const eps = 1e-9;
  function alloc() {
    const scores = portfolio.map(p => {
      if ((p.signal==='BUY'||p.signal==='SELL') && p.expectedWinPct>0 && p.maxLossPct>0) {
        return p.expectedWinPct/(p.maxLossPct+eps);
      }
      return 0;
    });
    const scoreSum = scores.reduce((a,b)=>a+b,0);
    const amounts = portfolio.map((p,i)=>scoreSum<=0?0:(scores[i]/scoreSum)*budget);

    let allocHtml = `<table>
      <caption>Model-weighted allocation (Amount: ${formatNum(budget, 2)}%)</caption>
      <thead> <tr>
        <th>Symbol</th><th>Signal</th><th>Expected % Win</th><th>Max % Win</th><th>Max % Loss</th><th>Amount %</th>
      </tr>
       </thead><tbody>`;
    portfolio.forEach((p,i)=>{
      allocHtml+=`<tr>
        <td style="text-align:left">${p.name}</td>
        <td>${p.signal}</td>
        <td>${formatNum(p.expectedWinPct)}%</td>
        <td>${formatNum(p.maxWinPct)}%</td>
        <td>${formatNum(p.maxLossPct)}%</td>
        <td>${formatNum(amounts[i])}</td>
      </tr>`;
    });
    allocHtml+=`</tbody></table>`;
    document.getElementById('tables').innerHTML += allocHtml;
  }

  const script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/brain.js@2.0.0-beta.24/dist/browser.min.js';
  script.onload = async () => { await main(); };
  document.head.appendChild(script);
}
</script>
</body>
</html>


<!-- https://www.mexc.com/en-GB/auth/signup?inviteCode=3Soxn
<input id="apiKey"><br>
<input id="apiSecret" type="password"><br>
<button onclick="getData()">Get Data</button>
<pre id="out"></pre>

<script src="https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/crypto-js.min.js"></script>
<script>
async function getData(){
  const key = apiKey.value.trim(), secret = apiSecret.value.trim();
  const sign = q => CryptoJS.HmacSHA256(q, secret).toString();

  // Open Orders
  let ts = Date.now(), q = `timestamp=${ts}`, sig = sign(q);
  let orders = await fetch(`https://api.mexc.com/api/v3/openOrders?${q}&signature=${sig}`, {
    headers: {'X-MEXC-APIKEY': key}
  }).then(r=>r.json());

  // Account Info
  ts = Date.now(); q = `timestamp=${ts}`; sig = sign(q);
  let account = await fetch(`https://api.mexc.com/api/v3/account?${q}&signature=${sig}`, {
    headers: {'X-MEXC-APIKEY': key}
  }).then(r=>r.json());

  const equity = account.balances
    ? account.balances.reduce((s,b)=>s+parseFloat(b.free)+parseFloat(b.locked),0)
    : null;

  out.textContent = JSON.stringify({openOrders: orders, totalEquity: equity}, null, 2);
}
</script>


</body>
</html> -->
