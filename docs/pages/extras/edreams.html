<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <title>Hist√≥rico & Previs√£o IA ‚Äì EuroDreams / Euromilh√µes / Totoloto</title>
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f4f4f9; color: #333; padding: 20px; }
    h2 { color: #2c3e50; }
    pre { background: #1e1e1e; color: #00ff00; padding: 16px; border-radius: 6px; max-height: 70vh; overflow: auto; font-family: 'Consolas', monospace; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
    button { background-color: #007bff; color: white; border: none; padding: 10px 20px; font-size: 1rem; cursor: pointer; border-radius: 4px; transition: background 0.3s; margin-top: 10px; }
    button:hover { background-color: #0056b3; }
    select { padding: 8px 12px; font-size: 1rem; border-radius: 4px; border: 1px solid #ccc; }
    label { font-weight: bold; margin-right: 10px; }
    .destaque { color: #ffeb3b; font-weight: bold; }
  </style>
</head>
<body>

<h2>üîÆ Previs√£o Avan√ßada ‚Äì Jogos Santa Casa</h2>

<label>
  Jogo:
  <select id="jogo">
    <option value="eurodreams">EuroDreams</option>
    <option value="euromilhoes">Euromilh√µes</option>
    <option value="totoloto">Totoloto</option>
  </select>
</label>

<button onclick="carregarHistorico()">Calcular Previs√£o Avan√ßada</button>

<pre id="resultado">Escolhe o jogo e clica no bot√£o para iniciar a IA...</pre>

<script>
// -------------------------------------------------------
// CONFIGURA√á√ÉO POR JOGO
// -------------------------------------------------------
const WORKER = "https://superdb-api.superbem.workers.dev/gethtml";
const PROXY = url => "https://corsproxy.io/?" + encodeURIComponent(url);

const JOGOS = {
  eurodreams: {
    nome: "EuroDreams",
    url: "https://www.jogossantacasa.pt/web/ResultsBoard/EuroDreams",
    selectName: "selectContest",
    seletorChave: ".betMiddle.twocol.regPad .colums li",
    seletorData: ".dataInfo",
    parseChave: texto => {
      if (!texto.includes("+")) return null;
      const [nums, sorte] = texto.split("+");
      return {
        combinacao: nums.trim().split(/\s+/).map(Number),
        extras: [parseInt(sorte.trim())]
      };
    },
    numerosPrincipais: 6,
    extrasLabel: "N√∫mero da Sorte"
  },

  euromilhoes: {
    nome: "Euromilh√µes",
    url: "https://www.jogossantacasa.pt/web/SCCartazResult",
    selectName: "selectContest",
    seletorChave: ".betMiddle .colums li",
    seletorData: ".dataInfo",
    parseChave: texto => {
      if (!texto.includes("+")) return null;
      const [nums, estrelas] = texto.split("+");
      return {
        combinacao: nums.trim().split(/\s+/).map(Number),
        extras: estrelas.trim().split(/\s+/).map(Number)
      };
    },
    numerosPrincipais: 5,
    extrasLabel: "Estrelas"
  },

  totoloto: {
    nome: "Totoloto",
    url: "https://www.jogossantacasa.pt/web/SCCartazResult/totolotoNew",
    selectName: "selectContest",
    seletorChave: ".betMiddle .colums li",
    seletorData: ".dataInfo",
    parseChave: texto => {
      if (!texto.includes("+")) return null;
      const [nums, suplente] = texto.split("+");
      return {
        combinacao: nums.trim().split(/\s+/).map(Number),
        extras: [parseInt(suplente.trim())]
      };
    },
    numerosPrincipais: 5,
    extrasLabel: "N√∫mero Extra"
  }
};

// -------------------------------------------------------
// UTILIT√ÅRIOS
// -------------------------------------------------------
function limparData(texto) {
  return texto.replace(/(segunda|ter√ßa|terca|quarta|quinta|sexta|s√°bado|sabado)(?=Data)/i, "$1 ").trim();
}

async function fetchHTML(url) {
  try {
    const target = PROXY(url);
    const resp = await fetch(target);
    const buffer = await resp.arrayBuffer();
    const decoder = new TextDecoder("iso-8859-1");
    return decoder.decode(buffer);
  } catch (e) {
    return null;
  }
}

function parseHTML(html) {
  return new DOMParser().parseFromString(html, "text/html");
}

// -------------------------------------------------------
// L√ìGICA AVAN√áADA DE PREDI√á√ÉO
// -------------------------------------------------------
function calcularPrevisaoAvancada(historico, cfg) {
  const statsNums = new Map();
  const statsExtras = new Map();
  const totalSorteios = historico.length;

  // Inicializar mapas
  const updateStat = (map, num, indexRecencia) => {
    if (!map.has(num)) {
      map.set(num, { 
        frequencia: 0, 
        pesoPonderado: 0, 
        ultimoIndice: indexRecencia,
        atraso: 0 
      });
    }
    const st = map.get(num);
    st.frequencia++;
    
    // C√ÅLCULO DE PESO (A M√ÅGICA):
    // 1. Frequ√™ncia base vale muito.
    // 2. Rec√™ncia: Sorteios mais recentes (index menor) valem mais pontos (Decaimento Exponencial).
    //    Isso ajuda a pegar n√∫meros "quentes".
    //    F√≥rmula: 1 / (Indice + 10) -> O +10 suaviza a curva.
    const pesoRecencia = 150 / (indexRecencia + 10); 
    
    st.pesoPonderado += 1 + pesoRecencia; 
    
    // Atualiza onde foi visto pela √∫ltima vez (menor indice = mais recente)
    if (indexRecencia < st.ultimoIndice) {
        st.ultimoIndice = indexRecencia;
    }
  };

  // Processar hist√≥rico (Assumindo historico[0] = mais recente)
  historico.forEach((h, index) => {
    h.combinacao.forEach(n => updateStat(statsNums, n, index));
    h.extras.forEach(e => {
        if (!isNaN(e)) updateStat(statsExtras, e, index);
    });
  });

  // Calcular atrasos e pontua√ß√£o final
  const finalizarScore = (map) => {
    return [...map.entries()].map(([num, st]) => {
      st.atraso = st.ultimoIndice; // √çndice 0 √© o √∫ltimo sorteio. √çndice 10 √© h√° 10 sorteios.
      
      // Pontua√ß√£o Final = (Peso Ponderado * 0.7) + (Fator Atraso * 0.3)
      // Se o atraso for gigante, damos um empurr√£ozinho, mas focamos na tend√™ncia (peso).
      let score = st.pesoPonderado;
      
      return { num, ...st, score };
    }).sort((a, b) => b.score - a.score); // Ordenar por Score Decrescente
  };

  const rankingNums = finalizarScore(statsNums);
  const rankingExtras = finalizarScore(statsExtras);

  // SELE√á√ÉO INTELIGENTE (Balanceamento Par/√çmpar)
  // Tenta pegar os melhores scores, mas garante que n√£o sejam todos pares ou todos √≠mpares.
  const selecionados = [];
  let pares = 0;
  let impares = 0;
  
  // Pegamos um pool maior (top 2x a quantidade necess√°ria) para filtrar
  const candidatos = rankingNums.slice(0, cfg.numerosPrincipais * 2);

  for (const c of candidatos) {
    if (selecionados.length === cfg.numerosPrincipais) break;

    const ehPar = c.num % 2 === 0;
    
    // Regra de Ouro: Evitar desbalan√ßo total
    // Se j√° tenho muitos pares, pulo este par. Se j√° tenho muitos impares, pulo este √≠mpar.
    // Limite suave: 60-70% max de um tipo.
    const maxTipo = Math.ceil(cfg.numerosPrincipais * 0.65);
    
    if (ehPar && pares >= maxTipo) continue;
    if (!ehPar && impares >= maxTipo) continue;

    selecionados.push(c.num);
    if (ehPar) pares++; else impares++;
  }

  // Caso o filtro tenha sido muito restrito e faltem n√∫meros, preenche com os pr√≥ximos melhores ignorando filtro
  let i = 0;
  while (selecionados.length < cfg.numerosPrincipais && i < rankingNums.length) {
      if (!selecionados.includes(rankingNums[i].num)) {
          selecionados.push(rankingNums[i].num);
      }
      i++;
  }

  // Extras (sem filtro par/√≠mpar, apenas score puro)
  // Quantidade de extras depende do jogo (EuroDreams=1, Euromilhoes=2, Totoloto=1)
  const qtdExtras = (historico[0]?.extras || []).length;
  const extrasSelecionados = rankingExtras.slice(0, qtdExtras).map(e => e.num);

  return {
    numeros: selecionados.sort((a, b) => a - b),
    extras: extrasSelecionados.sort((a, b) => a - b),
    analise: {
      pares,
      impares,
      topHot: rankingNums[0].num, // O n√∫mero mais quente do momento
      topCold: rankingNums[rankingNums.length - 1].num // O mais frio
    }
  };
}

// -------------------------------------------------------
// FLUXO PRINCIPAL
// -------------------------------------------------------
async function carregarHistorico() {
  const saida = document.getElementById("resultado");
  const jogoKey = document.getElementById("jogo").value;
  const cfg = JOGOS[jogoKey];

  saida.innerHTML = `Jogo: <b>${cfg.nome}</b>\nA analisar padr√µes matem√°ticos...\n`;

  // 1. Obter p√°gina
  const htmlPrincipal = await fetchHTML(cfg.url);
  if (!htmlPrincipal) {
    saida.textContent += "Erro ao acessar servidor. Tente novamente.";
    return;
  }
  const doc = parseHTML(htmlPrincipal);

  // 2. Identificar concursos
  const options = [...doc.querySelectorAll(`select[name="${cfg.selectName}"] option`)];
  // Pegamos apenas os 50 √∫ltimos para a previs√£o ser baseada em tend√™ncias recentes,
  // ou todos se preferir. Para "Tend√™ncia", 50-100 √© ideal. Vamos pegar todos mas o calculo pondera.
  const concursos = options
    .map(o => ({ id: o.value, texto: o.textContent.trim() }))
    .filter(c => c.id);

  saida.textContent += `Analisando base de dados de ${concursos.length} concursos...\nWait...\n`;

  const historico = [];

  // 3. Extrair dados (Limitado aos √∫ltimos 100 para ser r√°pido e pegar tend√™ncia atual)
  // Se quiser ler TUDO, remova o .slice(0, 100).
  const concursosParaLer = concursos; 

  for (const c of concursosParaLer) {
    const htmlConcurso = await fetchHTML(`${cfg.url}?${cfg.selectName}=${encodeURIComponent(c.id)}`);
    const docC = parseHTML(htmlConcurso);

    const chaveBruta = docC.querySelector(cfg.seletorChave)?.textContent.trim() || "";
    let dataSorteio = (docC.querySelector(cfg.seletorData)?.textContent || "").trim().split("\n").pop().trim();
    dataSorteio = limparData(dataSorteio);

    const parsed = cfg.parseChave(chaveBruta);
    if (parsed && parsed.combinacao.length) {
      historico.push({
        concurso: c.texto,
        data: dataSorteio,
        combinacao: parsed.combinacao,
        extras: parsed.extras || []
      });
    }
  }

  // Ordenar hist√≥rico por Data (Mais recente no √≠ndice 0)
  // O site √†s vezes traz misturado dependendo do select, vamos garantir.
  // Como a data √© string complexa, vamos confiar que o select vem ordenado (Newest First √© padr√£o).
  
  // Imprimir lista simples (√∫ltimos 5 apenas para n√£o poluir)
  let textoHistorico = historico.slice(0, 5).map(h => {
     return `${h.data} | ${h.combinacao.join("-")} + ${h.extras.join("-")}`;
  }).join("\n");
  
  saida.innerHTML = `Base carregada: ${historico.length} sorteios.\n\n√öltimos 5 resultados:\n${textoHistorico}\n... (hist√≥rico completo analisado internamente)\n`;

  // 4. Executar Algoritmo
  const prev = calcularPrevisaoAvancada(historico, cfg);

  const htmlPrevisao = `
--------------------------------------------------
üéØ PREVIS√ÉO ESTAT√çSTICA (${cfg.nome.toUpperCase()})
--------------------------------------------------
N√∫meros:  <span class="destaque">${prev.numeros.join("  ")}</span>
${cfg.extrasLabel}: <span class="destaque">${prev.extras.join("  ")}</span>

üìä Detalhes da An√°lise:
> Balanceamento: ${prev.analise.pares} Pares / ${prev.analise.impares} √çmpares
> Crit√©rio: Peso Ponderado (Frequ√™ncia Recente + Atraso)
> N√∫mero mais "quente" do momento: ${prev.analise.topHot}
--------------------------------------------------
`;

  saida.innerHTML += htmlPrevisao;
}
</script>

</body>
</html>