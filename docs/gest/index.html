<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <title>Gest (D1 via Worker)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; font-family:helvetica,arial,sans-serif; }
    #wrapper { width:995px; margin:0 auto; padding:0; text-align:center; position:relative; top:140px; }
    td { text-align:center; }
    .save { display:none; float:left; }
    table.fixed { table-layout:fixed; width:100%; }
    table.fixed td { overflow:hidden; }
    tr:nth-child(even) { background:#f0f0f0; }
    .left_fixed { position:fixed; z-index:1; width:16%; min-width:170px; top:0; bottom:0; left:0; border:1px solid #ddd; padding:6px; box-sizing:border-box; }
    .right_side { width:100%; float:right; max-width:calc(100% - 170px); }
    .top_side { position:fixed; z-index:1; width:100%; top:0; left:175px; background:#eee; min-height:140px; display:flex; flex-flow:row wrap; padding:8px; box-sizing:border-box; gap:8px; align-items:flex-start; }
    .toolbar { width:160px; display:flex; flex-direction:column; gap:6px; }
    .sqlbox { border:1px solid #aaa; background:#fafafa; height:130px; width:calc(100% - 177px - 155px); }
    .sqlbox textarea { width:100%; height:100%; border:0; resize:none; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; padding:6px; box-sizing:border-box; }
    .btn { height:28px; cursor:pointer; }
  </style>
</head>
<body>

<div class="left_fixed">
  <div style="margin-bottom:6px; font-weight:bold;">Tabelas</div>
  <select id="tables" size="8" onchange="tablechange(this.value)" style="min-width:170px; width:100%;"></select>

  <div style="margin:10px 0 6px; font-weight:bold;">Campos</div>
  <select id="selfields" size="10" style="min-width:170px; width:100%;"></select>
</div>

<div class="right_side">
  <div class="top_side">
    <div class="toolbar">
      <input id="descrsql" placeholder="descrição" />
      <button class="btn" onclick="runsql()">Run</button>
      <label style="display:flex; align-items:center; gap:6px;">
        <input id="autorun" type="checkbox" title="autorun" /> autorun
      </label>
      <button class="btn" onclick="savesql()">Save</button>
      <button class="btn" onclick="toggleAdmin()">Admin</button>
      <small id="adminStatus" style="color:#666;"></small>
    </div>
    <div class="sqlbox">
      <textarea id="txtsql" spellcheck="false" placeholder="Escreva SQL aqui. Ex.: SELECT * FROM tabGest ORDER BY id DESC LIMIT 50;"
        onkeypress="if(event.key==='Enter' && !event.shiftKey){event.preventDefault(); runsql();}">
      </textarea>
    </div>
  </div>

  <div id="wrapper"></div>
</div>

<script>
  // =========================
  // Config
  // =========================
  const ENDPOINT = "https://superdb-api.superbem.workers.dev/sql";
  // Opcional: defina um token de admin (quando o Worker exigir Authorization: Bearer <token> para INSERT/UPDATE/DELETE).
  // Deixe null para ocultar botões de escrita.
  let ADMIN_TOKEN = null; // "COLOQUE_SEU_TOKEN_AQUI_SE_FOR_PRIVADO";

  // =========================
  // Estado
  // =========================
  let data_table = "tabGest";
  let head = [];         // [{ name: 'col' }, ...]
  let tableobj = [];     // rows atuais
  let adminEnabled = false;

  // =========================
  // Helpers
  // =========================
  function wantsWrite(sql) {
    return /^\s*(insert|update|delete|create|drop|alter|replace|pragma|attach|vacuum|begin|commit|rollback)\b/i.test(sql);
  }

  async function api(sql, params = []) {
    const headers = { "Content-Type": "application/json" };
    if (wantsWrite(sql) && adminEnabled && ADMIN_TOKEN) {
      headers["Authorization"] = "Bearer " + ADMIN_TOKEN;
    }
    const resp = await fetch(ENDPOINT, {
      method: "POST",
      headers,
      body: JSON.stringify({ sql, params })
    });
    const data = await resp.json().catch(() => ({}));
    if (!resp.ok || data.success === false) {
      throw new Error((data && data.error) || `HTTP ${resp.status}`);
    }
    return data;
  }

  function inferTableFromSQL(sql) {
    const m = /\bfrom\s+([^\s;]+)/i.exec(sql);
    return m ? m[1].replace(/["`]/g, "") : "";
  }

  function buildPlaceholders(n) {
    return Array.from({ length: n }).map(() => "?").join(", ");
  }

  function genlink(field, vals) {
    if (field === "link") {
      const parts = String(vals || "").replace(/\n/g, " ").split(" ");
      let html = "";
      for (const p of parts) {
        const m = /^https?:\/\/([^\/?#]+)(?:[\/?#]|$)/i.exec(p);
        const host = m && m[1];
        if (host) {
          let label = host.replace(/^www\./, "");
          const bits = label.split(".");
          label = bits.length === 3 ? bits[0] + bits[1] : bits[0];
          html += `<a href="${p}" target="_blank" rel="noopener">${label}</a> `;
        }
      }
      return html || vals;
    }
    if (field === "data") {
      const d = new Date(vals);
      if (!isNaN(d)) return d.toISOString().slice(0, 10);
    }
    return vals;
  }

  function toggleAdmin() {
    adminEnabled = !!ADMIN_TOKEN && !adminEnabled ? true : !adminEnabled;
    document.getElementById("adminStatus").textContent = adminEnabled
      ? "admin ativo"
      : (ADMIN_TOKEN ? "admin inativo" : "admin desativado (sem token)");
    // Re-render para mostrar/ocultar botões
    renderTable(tableobj);
  }

  // =========================
  // UI de tabela
  // =========================
  function genbuttons(rowIndex, row) {
    if (!adminEnabled || !ADMIN_TOKEN) {
      return `<td style="width:150px;"></td>`;
    }
    const bid = data_table + rowIndex;
    return `
      <td style="width:150px;">
        <input style="float:left;" type="button" id="edit_button${bid}" value="E" class="edit" onclick="editrow('${data_table}', ${rowIndex})">
        <input style="float:left;" type="button" id="save_button${bid}" value="S" class="save" onclick="saverow('${data_table}', ${rowIndex})">
        <input style="float:left;" type="button" value="D" class="delete" onclick="deleterow('${data_table}', ${rowIndex})">
      </td>
    `;
  }

  function genreg(table, field, rowIndex, val) {
    return `<td id="${table}${field}${rowIndex}">${genlink(field, val ?? "")}</td>`;
  }

  function geninsertrow() {
    if (!adminEnabled || !ADMIN_TOKEN) return "";
    let html = `<tr><td><input id="add_row" type="button" class="add" onclick="insertrow();" value="Add Row"></td>`;
    for (const col of head) {
      html += `<td><input style="width:100%;" type="text" id="new${col.name}"></td>`;
    }
    html += `</tr>`;
    return html;
  }

  function renderTable(rows) {
    const wrapper = document.getElementById("wrapper");
    if (!rows || rows.length === 0) {
      wrapper.innerHTML = `<div style="padding:10px;">Sem resultados.</div>`;
      return;
    }

    // HEAD: se não vier de PRAGMA, inferir das chaves
    if (!head || head.length === 0) {
      const keys = Object.keys(rows[0] || {});
      head = keys.map(k => ({ name: k }));
    }

    let html = "";
    html += `<table class="fixed" border="1" cellpadding="0" cellspacing="0" id="${data_table}">`;
    html += `<col width="70" /><col width="50" />`;
    html += `<tr><td style="width:150px;"></td>`;
    for (const c of head) html += `<td>${c.name}</td>`;
    html += `</tr>`;

    // Linha de insert
    html += geninsertrow();

    for (let i = 0; i < rows.length; i++) {
      const rowIndex = i + 1;
      const bid = data_table + rowIndex;
      html += `<tr id="row${bid}">`;
      html += genbuttons(rowIndex, rows[i]);
      for (const c of head) {
        html += genreg(data_table, c.name, rowIndex, rows[i][c.name]);
      }
      html += `</tr>`;
    }
    html += `</table>`;

    wrapper.innerHTML = html;
    if (!adminEnabled || !ADMIN_TOKEN) {
      // Oculta botões de edição/deleção
      for (const el of document.getElementsByClassName("edit")) el.style.display = "none";
      for (const el of document.getElementsByClassName("delete")) el.style.display = "none";
    }
  }

  // =========================
  // Edição
  // =========================
  async function saverow(table, rowIndex) {
    if (!adminEnabled || !ADMIN_TOKEN) return;
    const bid = table + rowIndex;
    const vals = [];
    const params = [];

    // Precisamos de uma PK (assume coluna 'id')
    const row = tableobj[rowIndex - 1];
    if (!row || typeof row.id === "undefined") {
      alert("Não foi encontrada a coluna 'id' para salvar.");
      return;
    }

    for (const col of head) {
      const namefield = col.name;
      const bidn = bid + namefield;
      const ta = document.getElementById("txtarea" + bidn);
      if (!ta) continue;
      let v = ta.value;
      params.push(v);
      vals.push(`${namefield} = ?`);
      // pós-salvar: render simples
      row[namefield] = v;
      document.getElementById("txtarea" + bidn).outerHTML = genlink(namefield, v);
    }

    const sql = `UPDATE ${table} SET ${vals.join(", ")} WHERE id = ?`;
    params.push(row.id);

    try {
      await api(sql, params); // write
    } catch (e) {
      alert("Erro ao salvar: " + e.message);
      return;
    }

    document.getElementById("edit_button" + bid).style.display = "block";
    document.getElementById("save_button" + bid).style.display = "none";
  }

  function editrow(table, rowIndex) {
    if (!adminEnabled || !ADMIN_TOKEN) return;
    const bid = table + rowIndex;
    const row = tableobj[rowIndex - 1];

    const eb = document.getElementById("edit_button" + bid);
    const sb = document.getElementById("save_button" + bid);
    if (eb) eb.style.display = "none";
    if (sb) sb.style.display = "block";

    for (const col of head) {
      const namefield = col.name;
      const reg = document.getElementById(table + namefield + rowIndex);
      const bidn = bid + namefield;
      const value = row[namefield] ?? "";
      reg.innerHTML =
        `<textarea autocomplete="on" id="txtarea${bidn}" style="background-color:orange; resize:none; width:100%;">` +
        String(value) +
        `</textarea>`;
    }
  }

  async function deleterow(table, rowIndex) {
    if (!adminEnabled || !ADMIN_TOKEN) return;
    const row = tableobj[rowIndex - 1];
    if (!row || typeof row.id === "undefined") {
      alert("Não foi encontrada a coluna 'id' para deletar.");
      return;
    }
    if (!confirm(`Apagar registro id=${row.id}?`)) return;
    try {
      await api(`DELETE FROM ${table} WHERE id = ?`, [row.id]);
      document.getElementById("row" + table + rowIndex).outerHTML = "";
    } catch (e) {
      alert("Erro ao deletar: " + e.message);
    }
  }

  async function insertrow() {
    if (!adminEnabled || !ADMIN_TOKEN) return;
    const names = [];
    const params = [];
    for (const col of head) {
      const inp = document.getElementById("new" + col.name);
      if (!inp) continue;
      let v = inp.value;
      if (v !== "") {
        names.push(col.name);
        params.push(v);
      }
    }
    if (names.length === 0) return;

    const sql = `INSERT INTO ${data_table} (${names.join(", ")}) VALUES (${buildPlaceholders(names.length)})`;

    try {
      await api(sql, params);
      runsql(); // recarrega
    } catch (e) {
      alert("Erro ao inserir: " + e.message);
    }
  }

  // =========================
  // Data loading
  // =========================
  async function getTables() {
    const { rows } = await api(`SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name`);
    const sel = document.getElementById("tables");
    sel.innerHTML = "";
    for (const r of rows) {
      const opt = document.createElement("option");
      opt.textContent = r.name;
      opt.value = r.name;
      sel.appendChild(opt);
    }
  }

  async function getSchema(table) {
    const { rows } = await api(`PRAGMA table_info(${table})`);
    head = rows.map(r => ({ name: r.name }));
    // Atualiza lista de campos
    const sel = document.getElementById("selfields");
    sel.innerHTML = "";
    for (const c of head) {
      const opt = document.createElement("option");
      opt.textContent = c.name;
      opt.value = c.name;
      sel.appendChild(opt);
    }
  }

  async function getdata(sql) {
    // Tentar identificar tabela para schema
    const maybeTable = inferTableFromSQL(sql);
    if (maybeTable) {
      data_table = maybeTable;
      try { await getSchema(data_table); } catch {}
    } else {
      head = [];
    }

    const { rows } = await api(sql);
    tableobj = rows || [];
    renderTable(tableobj);
  }

  async function tablechange(val) {
    if (!val) return;
    data_table = val;
    await getSchema(val);
    await getdata(`SELECT * FROM ${val} ORDER BY id DESC LIMIT 200`);
    document.getElementById("txtsql").value = `SELECT * FROM ${val} ORDER BY id DESC LIMIT 200;`;
  }

  function runsql() {
    const tsql = document.getElementById("txtsql").value.trim();
    if (!tsql) return;
    const sql = tsql.split(";")[0].replace(/`/g, '"');
    getdata(sql).catch(e => alert("Erro: " + e.message));
  }

  function savesql() {
    alert("Salvar consultas: implemente usando uma tabela própria (ex.: tabSql) e chamadas autenticadas.");
  }

  // =========================
  // Boot
  // =========================
  async function boot() {
    document.getElementById("adminStatus").textContent =
      ADMIN_TOKEN ? "admin inativo" : "admin desativado (sem token)";

    await getTables().catch(() => {});
    // Consulta inicial padrão
    document.getElementById("txtsql").value = `SELECT * FROM ${data_table} ORDER BY id DESC LIMIT 50;`;
    runsql();
  }
  boot();
</script>

</body>
</html>
